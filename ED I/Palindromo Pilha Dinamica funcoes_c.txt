//funcoes.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "funcoes.h"

// Fun√ß√£o para limpar a tela e aguardar a press√£o de ENTER üöø‚è≥
void limpar() 
{
    printf("\n\n%süõë %sPressione ENTER para continuar... %süõë%s: ", LIGHT_CYAN, LIGHT_YELLOW, LIGHT_CYAN, RESET);
    getchar();  // ‚è≥ Espera a entrada do usu√°rio
    #ifdef _WIN32
        system("cls");  // üñ•Ô∏è Comando espec√≠fico para Windows para limpar a tela
    #else
        system("clear");  // üçè Comando espec√≠fico para Linux/Mac para limpar a tela
    #endif
}

// Fun√ß√£o para limpar o buffer de entrada üßπ
void limparbuffer() 
{
    int c;
    while ((c = getchar()) != '\n' && c != EOF);
}

// Fun√ß√£o para exibir mensagens de boas-vindas sobre uma pilha de pal√≠ndromos üååüí§
void boasVindas() 
{
    printf("\n" PINK BOLD "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" RESET "\n");
    printf(PINK BOLD "‚ïë" RESET " üåü‚ú® " BOLD PINK "Bem-vindo √† " RESET PINK BOLD "Pilha dos pal√≠ndromos" RESET PINK BOLD " ‚ú®üåü " PINK BOLD "                               ‚ïë" RESET "\n");
    printf(PINK BOLD "‚ïë" RESET " üåàüéâ " LIGHT_YELLOW "Os pal√≠ndromos s√£o a chave para a divers√£o, entre e descubra!" RESET PINK BOLD " üéâüåà " PINK BOLD "   ‚ïë" RESET "\n");
    printf(PINK BOLD "‚ïë" RESET " üå†üéà " MAGENTA "Cada pal√≠ndromo aqui √© √∫nico, prepare-se para se surpreender!" RESET PINK BOLD " üéàüå† " PINK BOLD "   ‚ïë" RESET "\n");
    printf(PINK BOLD "‚ïë" RESET " üíñüåô " GREEN "Mergulhe na sua mente e deixe os pal√≠ndromos flu√≠rem!" RESET PINK BOLD " üåôüíñ " PINK BOLD "           ‚ïë" RESET "\n");
    printf(PINK BOLD "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" RESET "\n\n");
    limpar();  // Limpa a tela ap√≥s a mensagem de boas-vindas
}


// Fun√ß√£o para criar uma pilha din√¢mica de caracteres
pilhaDinamica* criarPilhaDinamica(void)
{
    pilhaDinamica* Ptp = (pilhaDinamica*)malloc(sizeof(pilhaDinamica));  // Aloca mem√≥ria para a pilha
    if (Ptp != NULL)
        Ptp->topo = NULL;  // Inicializa o topo da pilha como NULL
    return Ptp;  // Retorna o ponteiro para a pilha
}

// Fun√ß√£o para verificar se a pilha est√° vazia üõë
int pilhaVaziaDinamica(pilhaDinamica* Ptp)
{
    if (Ptp == NULL)
        return -1;  // Retorna -1 se a pilha for nula
    return Ptp->topo == NULL;  // Retorna 1 se a pilha estiver vazia
}

// Fun√ß√£o para empilhar um caractere na pilha din√¢mica
int pushPilhaDinamica(pilhaDinamica* Ptp, char letra)
{
    if (Ptp == NULL) {
        printf("Erro: Pilha nula. ‚ùå\n");  // Mensagem de erro se a pilha for nula
        return -1;  // Retorna -1 em caso de erro
    }

    Nodo* novoNodo = (Nodo*)malloc(sizeof(Nodo));  // Aloca mem√≥ria para o novo n√≥
    if (novoNodo == NULL) {
        printf("Erro: Falha na aloca√ß√£o de mem√≥ria. ‚ùå\n");  // Mensagem de erro se a aloca√ß√£o falhar
        return -1;  // Retorna -1 em caso de erro
    }

    novoNodo->letra = letra;  // Armazena a letra no novo n√≥
    novoNodo->proximo = Ptp->topo;  // O novo n√≥ aponta para o antigo topo
    Ptp->topo = novoNodo;  // O topo da pilha √© atualizado para o novo n√≥
    return 0;  // Retorna 0 em caso de sucesso
}

// Fun√ß√£o para desempilhar um caractere da pilha din√¢mica
int popPilhaDinamica(pilhaDinamica* Ptp, char* letraRemovida) {
    if (Ptp == NULL || pilhaVaziaDinamica(Ptp)) {
        printf(RED "üí§ A pilha est√° vazia ou nula.\n" RESET);  // Mensagem de erro se a pilha estiver vazia
        return -1;  // Retorna -1 em caso de erro
    }

    Nodo* temp = Ptp->topo;  // Armazena o topo da pilha em uma vari√°vel tempor√°ria
    *letraRemovida = temp->letra;  // Remove a letra do topo
    Ptp->topo = temp->proximo;  // Atualiza o topo da pilha
    free(temp);  // Libera a mem√≥ria do n√≥ removido
    return 0;  // Retorna 0 em caso de sucesso
}

// Fun√ß√£o para consultar o caractere no topo da pilha din√¢mica
int consultaTopoDinamica(pilhaDinamica* Ptp, char* letraConsultada)
{
    if (Ptp == NULL || pilhaVaziaDinamica(Ptp)) {
        printf(RED "üí§ A pilha est√° vazia ou nula.\n" RESET);  // Mensagem de erro se a pilha estiver vazia
        return -1;  // Retorna -1 em caso de erro
    }

    *letraConsultada = Ptp->topo->letra;  // Armazena a letra no topo na vari√°vel fornecida
    return 0;  // Retorna 0 em caso de sucesso
}

// Fun√ß√£o para liberar a mem√≥ria alocada para a pilha din√¢mica
void liberarPilhaDinamica(pilhaDinamica* Ptp) {
    if (Ptp != NULL) {
        Nodo* atual = Ptp->topo;  // Come√ßa do topo da pilha
        while (atual != NULL) {  // Enquanto houver n√≥s na pilha
            Nodo* temp = atual;  // Armazena o n√≥ atual
            atual = atual->proximo;  // Avan√ßa para o pr√≥ximo n√≥
            free(temp);  // Libera a mem√≥ria do n√≥
        }
        free(Ptp);  // Libera a mem√≥ria da estrutura da pilha
    }
}

// Fun√ß√£o para processar cada token e verificar pal√≠ndromos
int processarToken(pilhaDinamica* pilha, char* token, char* nomeDepois) {
    int cont;  // Contador para controlar a posi√ß√£o em nomeDepois

    // Inicializa o contador e limpa nomeDepois
    cont = 0;
    memset(nomeDepois, 0, sizeof(nomeDepois));  // Limpa nomeDepois para evitar lixo de mem√≥ria

    // Insere a palavra na pilha
    for (int i = 0; token[i] != '\0'; i++) {
        if (pushPilhaDinamica(pilha, token[i]) == -1) {  // Tenta empilhar cada caractere
            printf(RED "Erro ao empilhar a palavra: %s\n" RESET, token);  // Mensagem de erro ao empilhar
            return 0;  // Retorna 0 se houver erro ao empilhar
        }
    }

    // Remove elementos da pilha e armazena em nomeDepois
    while (pilha->topo != NULL) {
        char letraRemovida;  // Vari√°vel para armazenar letra removida
        if (popPilhaDinamica(pilha, &letraRemovida) == 0) {  // Tenta desempilhar
            nomeDepois[cont++] = letraRemovida;  // Armazena o caractere removido
        }
    }
    nomeDepois[cont] = '\0';  // Adiciona o terminador de string

    // Verifica se √© pal√≠ndromo
    return strcasecmp(token, nomeDepois) == 0;  // Compara a palavra original com a revertida
}

// Fun√ß√£o para substituir caracteres n√£o alfanum√©ricos por '\0' üßº
void substituirCaracteresEspeciais(char *str)
{
    for (int i = 0; str[i] != '\0'; i++)
    {
        if (!isalnum((unsigned char)str[i]))  // Verifica se o caractere n√£o √© alfanum√©rico
            str[i] = '\0';  // Substitui por '\0' se n√£o for alfanum√©rico
    }
}