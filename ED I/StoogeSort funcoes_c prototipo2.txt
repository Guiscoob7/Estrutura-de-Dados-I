//funcoes.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "funcoes.h"

// FunÃ§Ã£o para limpar a tela e aguardar a pressÃ£o de ENTER
void limpar() {
    // Solicita ao usuÃ¡rio para pressionar ENTER e limpar a tela
    printf("\n\n%sğŸ›‘ %sPressione ENTER para continuar... %sğŸ›‘%s: ", LIGHT_CYAN, LIGHT_YELLOW, LIGHT_CYAN, RESET);
    getchar();  // Espera a entrada do usuÃ¡rio
    #ifdef _WIN32
        system("cls");  // Comando especÃ­fico para Windows para limpar a tela
    #else
        system("clear");  // Comando especÃ­fico para Linux/Mac para limpar a tela
    #endif
}

// FunÃ§Ã£o para limpar o buffer de entrada
void limparbuffer() {
    int c;
    // Remove todos os caracteres do buffer de entrada atÃ© o fim da linha ou o EOF
    while ((c = getchar()) != '\n' && c != EOF);
}

// Cria uma lista duplamente encadeada de Emojis
Emoji *Cria_lista(ListaDuplamenteEncadeada *lista) {
    lista->cauda = NULL;  // Inicializa o ponteiro da cauda como NULL, indicando que a lista estÃ¡ vazia
    return NULL;         // Retorna NULL, pois a lista recÃ©m-criada ainda nÃ£o tem elementos
}


// FunÃ§Ã£o de inserÃ§Ã£o de emoji
Emoji* Insere(ListaDuplamenteEncadeada *ptL) {
    char aux2[16];        // Array para armazenar o sÃ­mbolo do emoji temporariamente
    Emoji* pt;            // Ponteiro para o novo Emoji a ser inserido
    // Alocando memÃ³ria para o novo emoji
    pt = (Emoji*)malloc(sizeof(Emoji));
    if(pt == NULL) {
        // Mensagem de erro se a alocaÃ§Ã£o de memÃ³ria falhar
        printf(RED "âŒ Erro: Falha ao alocar memÃ³ria!\n" RESET);
        return ptL->cabeca;  // Retorna a cabeÃ§a da lista sem modificaÃ§Ãµes
    }
    // Solicitando dados do Emoji ao usuÃ¡rio
    printf(BLUE "ğŸ²--- Dados do Emoji ---ğŸ²\n" RESET); // Usando BLUE para tÃ­tulos
    printf(YELLOW "ğŸ™‚ Emoji:\033[0m ");
    scanf("%s", aux2);
    limparbuffer();  // Limpa o buffer de entrada apÃ³s a leitura
    strcpy(pt->simbolo, aux2);  // Copia o sÃ­mbolo inserido para o novo Emoji
    // Solicitando e validando a popularidade do Emoji
    do {
        printf(YELLOW "ğŸ”¥ Popularidade:\033[0m ");
        scanf("%d", &pt->popularidade);
        limparbuffer();  // Limpa o buffer de entrada apÃ³s a leitura
    } while(pt->popularidade < 0);  // Garante que a popularidade nÃ£o seja negativa
    // Inicializa os ponteiros prÃ³ximo e anterior do novo Emoji
    pt->prox = NULL;
    pt->ant = NULL;
    // Insere o novo Emoji no final da lista
    if (ptL->cauda == NULL) {
        // Se a lista estiver vazia, o novo Emoji Ã© tanto a cabeÃ§a quanto a cauda
        ptL->cabeca = pt;
        ptL->cauda = pt;
    } else {
        // Se a lista jÃ¡ tiver elementos, ajusta os ponteiros para adicionar o Emoji ao final
        ptL->cauda->prox = pt;
        pt->ant = ptL->cauda;
        ptL->cauda = pt;
    }

    int cont = 0;
    // Exibindo a lista atualizada
    printf("\n" BLUE "ğŸ”¢--- Lista Atualizada ---\n" RESET);
    pt = ptL->cabeca;  // ComeÃ§a a exibiÃ§Ã£o a partir da cabeÃ§a da lista
    while(pt != NULL) {
        // Exibe o nÃºmero, sÃ­mbolo e popularidade do Emoji atual
        printf(YELLOW "%dÂº ğŸ“› Emoji " RESET, ++cont); // Estilo para o contador
        printf(GREEN "= %s" RESET, pt->simbolo); // Usando GREEN para o sÃ­mbolo
        printf(MAGENTA "ğŸŒŸ = %d" RESET, pt->popularidade); // Usando MAGENTA para a popularidade
        pt = pt->prox;  // Move para o prÃ³ximo Emoji na lista
        if (pt != NULL) {
            printf(", ");  // Adiciona uma vÃ­rgula entre Emojis, se houver mais
        }
    }
    printf("\n");

    // Retorna a cabeÃ§a da lista apÃ³s a inserÃ§Ã£o
    return ptL->cabeca;
}


void Exibe(ListaDuplamenteEncadeada *ptL) {
    Emoji* pt = ptL->cabeca;

    if (pt == NULL) {
        printf(RED "\nâŒ Lista vazia.\n" RESET); // Emoji para indicar lista vazia
        return;
    }

    printf("\n" BLUE "ğŸ“‹ --- Lista de Emojis ---\n" RESET); // Emoji de lista
    int cont = 0;
    while (pt != NULL) {
        printf(YELLOW "%dÂº ğŸ“› Emoji " RESET, ++cont); // Estilo para o contador
        printf(GREEN "= %s" RESET, pt->simbolo); // Emoji para cada entrada de sÃ­mbolo
        printf(MAGENTA " ğŸŒŸ = %d" RESET, pt->popularidade); // Emoji para a popularidade
        pt = pt->prox;
        if (pt != NULL) {
            printf(", ");
        }
    }
    printf("\n");
}


// FunÃ§Ã£o para remover Emojis com uma determinada popularidade
Emoji* Remove_elem(ListaDuplamenteEncadeada* Ptl, int popularidade, int *flag) {
    Emoji* atual = Ptl->cabeca;  // Inicia da cabeÃ§a da lista
    Emoji* aux;
    *flag = 0;  // Inicializa a flag de remoÃ§Ã£o como 0 (nenhum Emoji removido ainda)
    // Percorre a lista procurando Emojis com a popularidade especificada
    while (atual != NULL) {
        if (atual->popularidade == popularidade) {
            printf(BLUE "ğŸ—‘ï¸ Removendo Emoji(s) com popularidade %d...\n\n" RESET, popularidade);
            // Ajusta os ponteiros da lista duplamente encadeada para remover o Emoji
            if (atual == Ptl->cabeca) {
                Ptl->cabeca = atual->prox;  // Atualiza a cabeÃ§a da lista
                if (Ptl->cabeca != NULL) {
                    Ptl->cabeca->ant = NULL;  // Atualiza o ponteiro anterior da nova cabeÃ§a
                }
            } else {
                atual->ant->prox = atual->prox;  // Atualiza o prÃ³ximo do nÃ³ anterior
                if (atual->prox != NULL) {
                    atual->prox->ant = atual->ant;}  // Atualiza o anterior do nÃ³ prÃ³ximo
            }
            if (atual == Ptl->cauda) {
                Ptl->cauda = atual->ant;}  // Atualiza a cauda da lista
            // Libera a memÃ³ria do Emoji removido
            aux = atual;
            atual = atual->prox;
            free(aux);
            *flag = 1;  // Atualiza a flag indicando que um Emoji foi removido
            printf(GREEN "âœ… Emoji(s) com popularidade %d removido com sucesso!\n" RESET, popularidade);
        } else {
            atual = atual->prox;}  // Move para o prÃ³ximo Emoji
    }
    // Mensagem se nenhum Emoji com a popularidade especificada foi encontrado
    if (*flag == 0) {
        printf(YELLOW "âŒ Nenhum Emoji com popularidade %d encontrado para remoÃ§Ã£o.\n" RESET, popularidade);
    }
    return Ptl->cabeca;  // Retorna a nova cabeÃ§a da lista
}

// FunÃ§Ã£o para consultar um Emoji pelo sÃ­mbolo
int Consulta_elem(ListaDuplamenteEncadeada* Ptl, const char* emoji) {
    Emoji* atual = Ptl->cabeca;  // Inicia da cabeÃ§a da lista

    // Percorre a lista procurando o Emoji com o sÃ­mbolo especificado
    while (atual != NULL && strcmp(atual->simbolo, emoji) != 0) {
        atual = atual->prox;
    }

    // Verifica se o Emoji foi encontrado
    if (atual == NULL) {
        printf("%sğŸ’”ğŸ˜¢ %sEmoji nÃ£o encontrado! %sğŸ˜­ğŸ’§ %s\n", RED, CYAN, BLUE, RESET);
        return 0;  // Retorna 0 se o Emoji nÃ£o foi encontrado
    } else {
        printf("%sğŸ˜Šâ­ %sEmoji encontrado com sucesso! %sğŸ‰â­ %s\n\n", RED, GREEN, BLUE, RESET);
        // Exibe detalhes do Emoji encontrado
        printf("%sğŸŒŸğŸ”¥ %sEmoji: |------[%s]------| %sğŸš€ğŸŒˆ %s\n", RED, CYAN, atual->simbolo, MAGENTA, RESET);
        printf("%sğŸ’¥ğŸ’« %sPopularidade: %d %sâš¡ğŸŒ» %s\n\n", YELLOW, BLUE, atual->popularidade, MAGENTA, RESET);
        return 1;  // Retorna 1 se o Emoji foi encontrado
    }
}

// FunÃ§Ã£o para liberar toda a memÃ³ria usada pela lista
Emoji* Libera_lista(ListaDuplamenteEncadeada* Ptl) {
    Emoji* aux = Ptl->cabeca;  // Inicia da cabeÃ§a da lista

    // Percorre a lista liberando a memÃ³ria de cada Emoji
    while (aux != NULL) {
        Emoji* temp = aux;
        aux = aux->prox;
        free(temp);
    }

    Ptl->cauda = NULL;  // Define a cauda como NULL apÃ³s a liberaÃ§Ã£o da memÃ³ria
    return Ptl->cabeca;  // Retorna a nova cabeÃ§a da lista (que deve ser NULL)
}

// FunÃ§Ã£o para trocar os dados de dois Emojis
void trocar(Emoji* a, Emoji* b) {
    int tempPopularidade = a->popularidade;  // Armazena a popularidade de 'a' temporariamente
    char tempSimbolo[16];
    strcpy(tempSimbolo, a->simbolo);  // Armazena o sÃ­mbolo de 'a' temporariamente

    a->popularidade = b->popularidade;  // Troca a popularidade de 'a' com 'b'
    strcpy(a->simbolo, b->simbolo);  // Troca o sÃ­mbolo de 'a' com 'b'

    b->popularidade = tempPopularidade;  // Define a popularidade de 'b' para o valor original de 'a'
    strcpy(b->simbolo, tempSimbolo);  // Define o sÃ­mbolo de 'b' para o valor original de 'a'
}


// FunÃ§Ã£o de ordenaÃ§Ã£o Stooge Sort para a lista de Emojis
void stoogeSort(ListaDuplamenteEncadeada* Ptl, Emoji* l, Emoji* h) {
    // Verifica se a lista Ã© pequena demais para ordenar
    // Caso base: a lista Ã© vazia, possui um Ãºnico elemento, ou l e h sÃ£o o mesmo nÃ³
    // ou l e h sÃ£o adjacentes (isto Ã©, l estÃ¡ imediatamente antes de h)
    if (l == NULL || h == NULL || l == h || l->prox == h) return;
    // Verifica se Ã© necessÃ¡rio trocar os Emojis para garantir que 'l' esteja antes de 'h'
    // Se a popularidade do Emoji 'l' for maior do que a de 'h', troca os dados dos Emojis
    if (l->popularidade > h->popularidade) {
        trocar(l, h);} // Chama a funÃ§Ã£o 'trocar' para trocar os dados dos Emojis
    // Calcula o tamanho da sublista de Emojis entre l e h
    int tamanho = 1;  // Inicializa o tamanho com 1 porque l Ã© um elemento
    Emoji* temp = l;
    // Percorre a sublista para contar o nÃºmero total de elementos
    while (temp != h) {
        tamanho++;
        temp = temp->prox;}  // Move para o prÃ³ximo elemento na lista
    // Divide a lista em trÃªs partes e aplica o Stooge Sort recursivamente
    // O algoritmo Stooge Sort divide a lista em trÃªs partes iguais e ordena as duas partes externas
    // e a parte central
    if (tamanho > 2) {  // SÃ³ divide se o tamanho da lista for maior que 2
        int umTerco = tamanho / 3;  // Calcula o tamanho de um terÃ§o da lista
        // Determina o inÃ­cio do primeiro terÃ§o da sublista
        Emoji* primeiroTerco = l;
        for (int i = 0; i < umTerco; i++) {
            if (primeiroTerco != NULL) primeiroTerco = primeiroTerco->prox;}  // AvanÃ§a um terÃ§o da lista
        // Determina o inÃ­cio do segundo terÃ§o da sublista, comeÃ§ando do final e indo para trÃ¡s
        Emoji* doisTerco = h;
        for (int i = 0; i < umTerco; i++) {
            if (doisTerco != NULL) doisTerco = doisTerco->ant;}  // Retrocede um terÃ§o da lista
        // Aplica o Stooge Sort recursivamente nas trÃªs partes da lista
        // Ordena a sublista do inÃ­cio atÃ© o final do segundo terÃ§o
        if (primeiroTerco != NULL) stoogeSort(Ptl, l, doisTerco);
        // Ordena a sublista do inÃ­cio do primeiro terÃ§o atÃ© o final
        if (primeiroTerco != NULL && doisTerco != NULL) stoogeSort(Ptl, primeiroTerco, h);
        // Ordena novamente a sublista do inÃ­cio atÃ© o final do segundo terÃ§o
        if (primeiroTerco != NULL) stoogeSort(Ptl, l, doisTerco);}}


// FunÃ§Ã£o para ordenar a lista de Emojis
void ordenarLista(ListaDuplamenteEncadeada* Ptl) {
    if (Ptl->cabeca && Ptl->cauda) {
        printf(CYAN "ğŸ”„ Lista Inicial:\n" RESET);
        Exibe(Ptl);  // Exibe a lista inicial (ainda a ser implementado)
        printf("\n");

        limpar();  // Limpa a tela

        printf(YELLOW "ğŸš€ Iniciando a ordenaÃ§Ã£o com Stooge Sort...\n\n" RESET);
        stoogeSort(Ptl, Ptl->cabeca, Ptl->cauda);  // Ordena a lista usando Stooge Sort

        printf(GREEN "âœ… Lista Ordenada:\n" RESET);
        Exibe(Ptl);  // Exibe a lista ordenada (ainda a ser implementado)
        printf("\n");
    } else {
        printf(RED "âŒ A lista estÃ¡ vazia ou nÃ£o estÃ¡ corretamente inicializada.\n" RESET);
    }
}


/*
Maria isso deve ser executado no power shell para rodar Emoji
cd C:\Importante\C (caminho atÃ© a pasta em que se encontra o .exe)
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8 
.\programa.exe (nome do programa.exe)
*/

// FunÃ§Ã£o para exibir mensagens de boas-vindas sobre uma lista de Emojis
void boasVindas() {
    // Exibe uma borda superior da caixa de boas-vindas
    printf("\n" GREEN BOLD "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" RESET "\n");
    // Mensagem de boas-vindas com destaque para a "Lista de Emojis"
    printf(GREEN BOLD "â•‘" RESET " ğŸŒŸğŸ‰ " BOLD GREEN "Bem-vindo Ã  " RESET GREEN BOLD "Lista de Emojis do Zap" RESET GREEN BOLD " ğŸ‰ğŸŒŸ " GREEN BOLD "                              â•‘" RESET "\n");
    // Mensagem sobre explorar Emojis
    printf(GREEN BOLD "â•‘" RESET " ğŸ˜€ğŸ˜ " YELLOW "Explore uma seleÃ§Ã£o divertida de Emojis para usar!" RESET GREEN BOLD " ğŸ˜ğŸ˜€ " GREEN BOLD "              â•‘" RESET "\n");
    // Mensagem sobre escolher Ã­cones e expressÃµes
    printf(GREEN BOLD "â•‘" RESET " ğŸ¨ğŸ–¼ï¸ " MAGENTA "Escolha entre uma variedade de Ã­cones e expressÃµes!" RESET GREEN BOLD " ğŸ–¼ï¸ğŸ¨ " GREEN BOLD "             â•‘" RESET "\n");
    // Mensagem sobre personalizaÃ§Ã£o com Emojis
    printf(GREEN BOLD "â•‘" RESET " ğŸ› ï¸âœ¨ " GREEN "Personalize suas mensagens com Emojis Ãºnicos!" RESET GREEN BOLD " âœ¨ğŸ› ï¸ " GREEN BOLD "                   â•‘" RESET "\n");
    // Exibe uma borda inferior da caixa de boas-vindas
    printf(GREEN BOLD "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" RESET "\n\n");
}