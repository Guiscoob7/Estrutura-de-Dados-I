// main.c

#include <stdio.h>
#include <stdlib.h>
#include "funcoes.h"

int main() {
    int opcao;  // VariÃ¡vel para armazenar a opÃ§Ã£o escolhida pelo usuÃ¡rio
    // Alocando memÃ³ria para duas listas duplamente encadeadas
    ListaDuplamenteEncadeada* lista1 = (ListaDuplamenteEncadeada*)malloc(sizeof(ListaDuplamenteEncadeada));
    ListaDuplamenteEncadeada* lista2 = (ListaDuplamenteEncadeada*)malloc(sizeof(ListaDuplamenteEncadeada));
    ListaDuplamenteEncadeada* lista3 = (ListaDuplamenteEncadeada*)malloc(sizeof(ListaDuplamenteEncadeada));

    // Verifica se a alocaÃ§Ã£o de memÃ³ria foi bem-sucedida
    if (lista1 == NULL || lista2 == NULL || lista3 == NULL) {
        printf(RED "âŒ Erro ao alocar memÃ³ria para as listas.\n" RESET);
        return 1;  // Retorna erro se a alocaÃ§Ã£o falhar
    }

    // Cria as listas, inicializando a cabeÃ§a
    lista1->cabeca = Cria_lista(lista1);
    lista2->cabeca = Cria_lista(lista2);
    lista3->cabeca = Cria_lista(lista3);

    boasVindas();  // Exibe mensagem de boas-vindas
    limpar();      // Limpa a tela apÃ³s a mensagem de boas-vindas

    // Menu interativo
    do {
        exibeMenu();  // Exibe o menu de opÃ§Ãµes
        scanf("%d", &opcao);  // LÃª a opÃ§Ã£o escolhida
        limparbuffer();  // Limpa o buffer de entrada
        limpar();  // Limpa a tela apÃ³s cada interaÃ§Ã£o

        // Switch para tratar a opÃ§Ã£o escolhida
        switch (opcao) {
            case 1:  // Inserir Emoji
                Insere(lista1);
                limpar();
                break;
            case 2:  // Exibir Emojis
                Exibe(lista1);
                limpar();
                break;
            case 3:  // Ordenar Emojis
                ordenarLista(lista1);
                limpar();
                break;
            case 4: {  // Consultar Emoji
                char emojiParaConsultar[16];  // Tamanho suficiente para um emoji UTF-8
                printf(CYAN "\nğŸ” Digite o emoji para consultar: " RESET);
                scanf("%16s", emojiParaConsultar);  // LÃª atÃ© 16 caracteres
                limparbuffer();
                Consulta_elem(lista1, emojiParaConsultar);  // Consulta o emoji
                limpar();
                break;
            }
            case 5: {  // Remover Emoji por popularidade
                int flag;  // Flag para verificar se algum Emoji foi removido
                int popularidadeParaRemover;  // Armazena a popularidade do emoji a ser removido
                printf(CYAN "\nğŸ—‘ï¸  Digite a popularidade dos emojis a remover: " RESET);
                scanf("%d", &popularidadeParaRemover);
                limparbuffer();
                Remove_elem(lista1, popularidadeParaRemover, &flag);  // Remove o emoji
                limpar();
                break;
            }
            case 6: {  // Unir duas listas
                unirListas(lista1, lista2);  // Chama a funÃ§Ã£o de unir listas
                limpar();
                break;
            }
            case 7:  // Analisar complexidade
                analiseTempo(lista3);  // Chama a funÃ§Ã£o de anÃ¡lise de complexidade
                limpar();
                break;
            case 8:  // Analisar estabilidade
                analiseEstabilidade(lista3);  // Chama a funÃ§Ã£o de anÃ¡lise de estabilidade
                limpar();
                break;
            case 9:  // Sair do programa
                printf(GREEN "ğŸ‘‹ Saindo do programa. AtÃ© logo!\n" RESET);
                break;
            case 10:
                reiniciarLista(lista1); // Reinicia a Lista1 (Segredo de Desenvolvedor shhhhh....  ğŸ¤«)
                reiniciarLista(lista2); // Reinicia a Lista2 (Segredo de Desenvolvedor shhhhh....  ğŸ¤«)
                reiniciarLista(lista3); // Reinicia a Lista3 (Segredo de Desenvolvedor shhhhh....  ğŸ¤«)
                printf(RED "âŒ OpÃ§Ã£o invÃ¡lida. Tente novamente.\n" RESET);
                limpar();
            break;
            default:  // OpÃ§Ã£o invÃ¡lida
                printf(RED "âŒ OpÃ§Ã£o invÃ¡lida. Tente novamente.\n" RESET);
                limpar();
        }
    } while (opcao != 9);  // Continua atÃ© que o usuÃ¡rio escolha sair

    // Libera a memÃ³ria alocada para as listas e as estruturas
    Libera_lista(lista1);
    Libera_lista(lista2);
    Libera_lista(lista3);

    return 0;  // Retorna 0 ao finalizar com sucesso
}
