//funcoes.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include "funcoes.h"

#define TAM_SEQUENCIA 4

// Fun√ß√£o para limpar a tela e aguardar a press√£o de ENTER üöø‚è≥
void limpar() 
{
    // üõë Solicita ao usu√°rio para pressionar ENTER e limpar a tela
    printf("\n\n%süõë %sPressione ENTER para continuar... %süõë%s: ", LIGHT_CYAN, LIGHT_YELLOW, LIGHT_CYAN, RESET);
    getchar();  // ‚è≥ Espera a entrada do usu√°rio
    #ifdef _WIN32
        system("cls");  // üñ•Ô∏è Comando espec√≠fico para Windows para limpar a tela
    #else
        system("clear");  // üçè Comando espec√≠fico para Linux/Mac para limpar a tela
    #endif
}

void limparImediato()
{
    #ifdef _WIN32
        system("cls");  // üñ•Ô∏è Comando espec√≠fico para Windows para limpar a tela
    #else
        system("clear");  // üçè Comando espec√≠fico para Linux/Mac para limpar a tela
    #endif
}

// Fun√ß√£o para limpar o buffer de entrada üßπ
void limparbuffer() 
{
    int c;
    // üßπ Remove todos os caracteres do buffer de entrada at√© o fim da linha ou o EOF
    while ((c = getchar()) != '\n' && c != EOF);
}

/*
üíª Instru√ß√µes de execu√ß√£o:
cd C:\Importante\C (caminho at√© a pasta em que se encontra o .exe)
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8 
.\programa.exe (nome do programa.exe)
*/

// Fun√ß√£o para exibir mensagens de boas-vindas sobre uma fila da morte ‚ö∞Ô∏èüíÄ
void boasVindas() 
{
    // Exibe uma borda superior da caixa de boas-vindas üååüí§
    printf("\n" BLUE BOLD "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" RESET "\n");
    // üåôüí≠ Mensagem de boas-vindas com destaque para a "Pilha dos Sonhos"
    printf(BLUE BOLD "‚ïë" RESET " üåôüí≠ " BOLD BLUE "Bem-vindo √† " RESET BLUE BOLD "Pilha dos Sonhos" RESET BLUE BOLD " üí≠üåô " BLUE BOLD "                                    ‚ïë" RESET "\n");
    // üåå‚ú® Mensagem sobre o poder dos sonhos
    printf(BLUE BOLD "‚ïë" RESET " üåå‚ú® " LIGHT_YELLOW "Os sonhos s√£o a chave para a imagina√ß√£o, entre e descubra!" RESET BLUE BOLD " ‚ú®üåå " BLUE BOLD "      ‚ïë" RESET "\n");
    // üå†üí§ Mensagem sobre os sonhos que aguardam
    printf(BLUE BOLD "‚ïë" RESET " üå†üí§ " MAGENTA "Cada sonho aqui √© √∫nico, prepare-se para se surpreender!" RESET BLUE BOLD " üí§üå† " BLUE BOLD "        ‚ïë" RESET "\n");
    // üí´üåô Mensagem sobre o mist√©rio dos sonhos
    printf(BLUE BOLD "‚ïë" RESET " üí´üåô " GREEN "Mergulhe na sua mente e deixe os sonhos flu√≠rem!" RESET BLUE BOLD " üåôüí´ " BLUE BOLD "                ‚ïë" RESET "\n");
    // Exibe uma borda inferior da caixa de boas-vindas üååüí§
    printf(BLUE BOLD "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" RESET "\n\n");
    limpar();
}

// Fun√ß√£o para exibir o menu principal com op√ß√µes ‚ö∞Ô∏èüî™
void exibeMenu() 
{
    printf(RED "\nüïØÔ∏èüí§ Bem-vindo ao Gerenciador da Pilha de Sonhos üí§üïØÔ∏è\n\n" RESET);
    printf(YELLOW "üìú Escolha seu destino:\n" RESET);
    printf(RED "üåå [1] - Adicionar Sonho\n" RESET);  
    printf(GREEN "üå† [2] - Exibir Sonhos\n" RESET);  
    printf(BLUE "üîç [3] - Consultar Sonho\n" RESET);  
    printf(CYAN "üóëÔ∏è [4] - Remover Sonho\n" RESET);  
    printf(MAGENTA "‚è≥ [5] - Analisar Tempo da Pilha Est√°tica\n" RESET);  
    printf(DOURADO "üìä [6] - Analisar Tempo da Pilha Din√¢mica\n" RESET);  
    printf(RED "üö™ [7] - Realizar Sonho\n" RESET);  
    printf(YELLOW "üìç [8] - Sair do Gerenciador de Sonhos\n" RESET);  
    printf(YELLOW "\nüëâ Fa√ßa sua escolha: " RESET);
}


pilhaDosSonhosEstatica* criarPilhaEstatica(void)
{
    pilhaDosSonhosEstatica *Ptp;
    Ptp = (pilhaDosSonhosEstatica*) malloc(sizeof(pilhaDosSonhosEstatica));
    if (Ptp != NULL)
        Ptp->topo = -1;
    return Ptp;
}

pilhaDosSonhosDinamica* criarPilhaDinamica(void){
    pilhaDosSonhosDinamica *Ptp = (pilhaDosSonhosDinamica*) malloc(sizeof(pilhaDosSonhosDinamica));
    if (Ptp != NULL)
        Ptp->topo = NULL;
    return Ptp;
}

int pilhaVaziaEstatica(pilhaDosSonhosEstatica* Ptp)
{
    if (Ptp == NULL)
        return -1;
    return Ptp->topo == -1;
}

int pilhaCheiaEstatica(pilhaDosSonhosEstatica* Ptp)
{
    if (Ptp == NULL)
        return -1;
    return Ptp->topo == MAX_PILHA-1;
}

int pilhaVaziaDinamica(pilhaDosSonhosDinamica* Ptp)
{
    if (Ptp == NULL)
        return -1;
    return Ptp->topo == NULL;
}

int pushPilhaEstatica(pilhaDosSonhosEstatica* Ptp, Sonho sonho)
{
    if (Ptp == NULL || pilhaCheiaEstatica(Ptp)) {
    printf("Erro: Pilha nula ou cheia. ‚ùå\n");
    return -1;
}

    Ptp->topo++;
    Ptp->sonho[Ptp->topo] = sonho;
    return 1;
}

int pushPilhaDinamica(pilhaDosSonhosDinamica* Ptp, Sonho sonho)
{
    if (Ptp == NULL)
        return -1;

    noDinamico* novoNo = (noDinamico*) malloc(sizeof(noDinamico));
    if (novoNo == NULL)
        return -1;

    novoNo->sonho = sonho;
    novoNo->prox = Ptp->topo;
    Ptp->topo = novoNo;
    return 1;
}

int popPilhaEstatica(pilhaDosSonhosEstatica* Ptp, Sonho* sonhoRemovido) {
    if (Ptp == NULL || pilhaVaziaEstatica(Ptp)) {
        return 0;
    }

    *sonhoRemovido = Ptp->sonho[Ptp->topo];
    Ptp->topo--;
    return 1;
}

int popPilhaDinamica(pilhaDosSonhosDinamica* Ptp, Sonho* sonhoRemovido) {
    if (Ptp == NULL || Ptp->topo == NULL) {
        return 0;
    }

    noDinamico* noRemovido = Ptp->topo;
    *sonhoRemovido = noRemovido->sonho;
    Ptp->topo = noRemovido->prox;

    free(noRemovido);
    return 1;
}

void exibirPilhaEstatica(pilhaDosSonhosEstatica* Ptp) {
    if (Ptp == NULL || pilhaVaziaEstatica(Ptp)) {
        printf(RED "\nüí§ A pilha est√° vazia ou nula.\n" RESET);
        return;
    }

    printf(LIGHT_CYAN BOLD "üìö Conte√∫do da Pilha Est√°tica:\n\n" RESET);
    for (int i = Ptp->topo; i >= 0; i--) {
        printf(LIGHT_YELLOW "üåü Sonho #%d:\n" RESET, i + 1);
        printf(PINK "  üîÆ Tipo: %s\n" RESET, Ptp->sonho[i].tipo);
        printf(LIME "  üí≠ Intensidade Emocional: %d\n" RESET, Ptp->sonho[i].intensidadeEmocional);
        printf(CYAN "  üìú Descri√ß√£o: %s\n\n" RESET, Ptp->sonho[i].descricao);
    }
}

void exibirPilhaDinamica(pilhaDosSonhosDinamica* Ptp) {
    if (Ptp == NULL || Ptp->topo == NULL) {
        printf(RED "\nüí§ A pilha est√° vazia ou nula.\n" RESET);
        return;
    }

    printf(LIGHT_BLUE BOLD "üìö Conte√∫do da Pilha Din√¢mica:\n\n" RESET);
    noDinamico* atual = Ptp->topo;
    int contador = 1;

    while (atual != NULL) {
        printf(LIGHT_GREEN "‚ú® Sonho #%d:\n" RESET, contador);
        printf(PINK "  üîÆ Tipo: %s\n" RESET, atual->sonho.tipo);
        printf(LIME "  üí≠ Intensidade Emocional: %d\n" RESET, atual->sonho.intensidadeEmocional);
        printf(CYAN "  üìú Descri√ß√£o: %s\n\n" RESET, atual->sonho.descricao);

        atual = atual->prox;  // Passa para o pr√≥ximo n√≥
        contador++;
    }
}


int consultaTopoEstatica(pilhaDosSonhosEstatica* Ptp, Sonho *sonhos)
{
    if (Ptp->topo == -1) {  // Verifica se a pilha est√° vazia
        printf("‚ö†Ô∏è A pilha est√° vazia!\n");
        return 0;  // Retorna 0 para indicar que n√£o foi poss√≠vel consultar
    }

    *sonhos = Ptp->sonho[Ptp->topo];
    return 1;
}

int consultaTopoDinamica(pilhaDosSonhosDinamica* Ptp, Sonho* sonho)
{
    if (Ptp->topo == NULL) {  // Verifica se a pilha est√° vazia
        printf("‚ö†Ô∏è A pilha est√° vazia!\n");
        return 0;  // Retorna 0 para indicar que n√£o foi poss√≠vel consultar
    }

    *sonho = Ptp->topo->sonho;
    return 1;
}

void liberarPilhaEstatica (pilhaDosSonhosEstatica *Ptp)
{
    if (Ptp != NULL)
    {
        free(Ptp);
        printf(LIME "‚ôªÔ∏è Pilha Est√°tica liberada com sucesso!\n" RESET);
    }
}

void liberarPilhaDinamica (pilhaDosSonhosDinamica *Ptp)
{
    if (Ptp != NULL)
    {
        noDinamico *temp;
        while (Ptp->topo != NULL)
        {
            temp = Ptp->topo;
            Ptp->topo = Ptp->topo->prox;
            free(temp);
        }
    }
    free(Ptp);
    printf(AQUA "‚ôªÔ∏è Pilha Din√¢mica liberada com sucesso!\n" RESET);
}

// Fun√ß√£o para gerar professores aleat√≥rios com "crimes" engra√ßados
Sonho gerarSonhos()
{
    Sonho sonho;
    strcpy(sonho.tipo, "");
    strcpy(sonho.descricao, "");
    int max = 19;
    int min = 0;

    // Lista de tipos de sonhos
    char *tipos[] = {
        "Pesadelo com monstros",
        "Sonho de voar sem asas",
        "Sonho em que cai de uma grande altura",
        "Sonho de perder os dentes",
        "Sonho de ser perseguido por algo",
        "Sonho com um futuro alternativo",
        "Sonho com fogo e destrui√ß√£o",
        "Sonho com pessoas falecidas",
        "Sonho em que se est√° preso em um lugar",
        "Sonho em que se ganha um pr√™mio inesperado",
        "Sonho com animais falantes",
        "Sonho de se tornar invis√≠vel",
        "Sonho com uma festa m√°gica",
        "Sonho de viajar para o passado",
        "Sonho com superpoderes",
        "Sonho de ser um her√≥i",
        "Sonho com uma casa gigante",
        "Sonho de voar em um foguete",
        "Sonho em que se encontra um tesouro"};

    // Lista de descri√ß√µes de sonhos
    char *descricoes[] = {
        "Voc√™ est√° sendo perseguido por uma criatura monstruosa que aparece em cada canto.",
        "Voc√™ come√ßa a flutuar no ar, como se estivesse voando, mas sem qualquer controle.",
        "Voc√™ est√° em um pr√©dio muito alto e, de repente, come√ßa a cair sem parar.",
        "De repente, voc√™ percebe que est√° perdendo todos os seus dentes, um por um.",
        "Voc√™ corre desesperado, mas h√° algo ou algu√©m que te persegue sem parar.",
        "Voc√™ acorda em um mundo paralelo, onde tudo √© muito diferente da sua realidade.",
        "O fogo toma conta de tudo ao seu redor, destruindo casas e √°rvores, mas voc√™ n√£o consegue escapar.",
        "Voc√™ encontra um ente querido, mas percebe que ele n√£o est√° mais entre os vivos.",
        "Voc√™ tenta abrir a porta para sair, mas est√° trancado em uma sala sem sa√≠da.",
        "Voc√™ encontra um bilhete que diz que voc√™ ganhou um pr√™mio enorme, mas ningu√©m mais parece saber de nada.",
        "Voc√™ conversa com um cachorro que come√ßa a te contar segredos sobre o universo.",
        "Voc√™ fica invis√≠vel e come√ßa a observar todos ao seu redor, mas logo percebe que est√° perdido.",
        "Voc√™ est√° em uma festa maravilhosa, cheia de pessoas que voc√™ nunca conheceu, mas se sente em casa.",
        "Voc√™ consegue viajar no tempo e encontra um momento que voc√™ gostaria de reviver.",
        "Voc√™ descobre que tem poderes especiais, como super for√ßa ou teletransporte.",
        "Voc√™ se v√™ salvando o mundo de um grande desastre e se torna um her√≥i de verdade.",
        "Voc√™ se perde em uma casa gigantesca, cheia de quartos e passagens secretas.",
        "Voc√™ decola em um foguete, indo para o espa√ßo e descobrindo planetas desconhecidos.",
        "Voc√™ encontra um mapa antigo e come√ßa a procurar por um tesouro enterrado."};

    // Escolher tipo de sonho e descri√ß√£o aleat√≥rios
    strcpy(sonho.tipo, tipos[gerarNumeroAleatorio(min, max)]);
    sonho.intensidadeEmocional = gerarNumeroAleatorio(min, max); // Gera a intensidade emocional
    strcpy(sonho.descricao, descricoes[gerarNumeroAleatorio(min, max)]);

    return sonho;
}

// Gera dados aleat√≥rios para um sonho üé≤üåô
Sonho gerarDados()  
{
    Sonho sonho;
    gerarStringAleatoria(sonho.tipo, 22);  // Gera um tipo aleat√≥rio para o sonho
    sonho.intensidadeEmocional = gerarNumeroAleatorio(1,100); // Gera a intensidade emocional
    gerarStringAleatoria(sonho.descricao, 44); // Gera uma descri√ß√£o aleat√≥ria para o sonho
    return sonho;
}

// Gera um caractere aleat√≥rio (letra mai√∫scula ou min√∫scula) üé≤üî†
char gerarCaractereAleatorio() 
{
    int tipo = rand() % 2;
    if (tipo == 0) return 'a' + rand() % 26;
    else return 'A' + rand() % 26;
}

// Gera uma string aleat√≥ria com tamanho especificado üé≤‚úèÔ∏è
void gerarStringAleatoria(char *str, int tamanho) 
{
    for (int i = 0; i < tamanho; i++)
        str[i] = gerarCaractereAleatorio();
    str[tamanho - 1] = '\0';  // Corrige a posi√ß√£o do terminador nulo
}

// Gera um n√∫mero aleat√≥rio entre 1 e 100 üé≤üî¢
int gerarNumeroAleatorio(int min, int max) 
{
    return rand() % (max - min + 1) + min;
}

void analisePilhaEstatica(pilhaDosSonhosEstatica *pilha, Sonho *sonho, double* tempos) {
    double start, finish;
    int cont = 0;
    int entradas[] = {1000, 3000, 5000, 10000, 25000};

    for (int i = 0; i < 5; i++) {
        // Medindo o tempo de inser√ß√£o
        start = (double) clock();
        for (int j = 0; j < entradas[i]; j++) {
            pushPilhaEstatica(pilha, gerarDados()); // Insere um sonho na pilha
        }
        finish = (double) clock();
        tempos[cont++] = finish - start; // Armazenando o tempo de inser√ß√£o

        // Medindo o tempo de exibi√ß√£o
        start = (double) clock();
        exibirPilhaEstatica(pilha); // Exibe os sonhos na pilha
        finish = (double) clock();
        tempos[cont++] = finish - start; // Armazenando o tempo de exibi√ß√£o

        // Medindo o tempo de remo√ß√£o
        start = (double) clock();
        for (int j = 0; j < entradas[i]; j++) {
            popPilhaEstatica(pilha, sonho); // Remove um sonho da pilha
        }
        finish = (double) clock();
        tempos[cont++] = finish - start; // Armazenando o tempo de remo√ß√£o
    }
}

void analisePilhaDinamica(pilhaDosSonhosDinamica *pilha, Sonho *sonho, double* tempos) {
    double start, finish;
    int cont = 0;
    int entradas[] = {1000, 3000, 5000, 10000, 25000};

    for (int i = 0; i < 5; i++) {
        // Medindo o tempo de inser√ß√£o
        start = (double) clock();
        for (int j = 0; j < entradas[i]; j++) {
            pushPilhaDinamica(pilha, gerarDados()); // Insere um sonho na pilha
        }
        finish = (double) clock();
        tempos[cont++] = finish - start; // Armazenando o tempo de inser√ß√£o

        // Medindo o tempo de exibi√ß√£o
        start = (double) clock();
        exibirPilhaDinamica(pilha); // Exibe os sonhos na pilha
        finish = (double) clock();
        tempos[cont++] = finish - start; // Armazenando o tempo de exibi√ß√£o

        // Medindo o tempo de remo√ß√£o
        start = (double) clock();
        for (int j = 0; j < entradas[i]; j++) {
            popPilhaDinamica(pilha, sonho); // Remove um sonho da pilha
        }
        finish = (double) clock();
        tempos[cont++] = finish - start; // Armazenando o tempo de remo√ß√£o
    }
}

// Fun√ß√£o para gerar uma sequ√™ncia de n√∫meros aleat√≥rios
void gerarSequencia(int *sequencia, int tamanho) {
    for (int i = 0; i < tamanho; i++) {
        sequencia[i] = rand() % 10; // N√∫meros de 0 a 9
    }
}

// Fun√ß√£o para exibir a sequ√™ncia de n√∫meros por um curto per√≠odo
void exibirSequencia(int *sequencia, int tamanho) {
    printf(GREEN "‚ú® A sequ√™ncia dos seus sonhos ser√° exibida por 3 segundos! Lembre-se bem...\n\n" RESET);
    printf("\t\t");
    for (int i = 0; i < tamanho; i++) {
        printf(YELLOW "%d " RESET, sequencia[i]);
    }
    printf("\n");

    sleep(3);  // Espera 3 segundos para o jogador memorizar

    limparImediato();
    printf(RED "\nüí• A sequ√™ncia desapareceu! Voc√™ tem 10 segundos para adivinhar... Vamos l√°!\n" RESET);
}

// Fun√ß√£o para desafiar o jogador a adivinhar a sequ√™ncia
int realizarSonho() {
    int sequencia[TAM_SEQUENCIA];
    int tentativa[TAM_SEQUENCIA];
    int acertou = 0;

    srand(time(NULL));  // Inicializa o gerador de n√∫meros aleat√≥rios

    // Gera a sequ√™ncia dos sonhos
    gerarSequencia(sequencia, TAM_SEQUENCIA);

    // Exibe a sequ√™ncia para o jogador por um curto tempo
    exibirSequencia(sequencia, TAM_SEQUENCIA);

    // Espera 10 segundos para o jogador tentar adivinhar
    printf(CYAN "\n‚è≥ Voc√™ tem 10 segundos para tentar adivinhar a sequ√™ncia dos seus sonhos. Comece agora!\n" RESET);
    sleep(1);  // Pequena pausa antes de come√ßar

    time_t start_time = time(NULL);  // Registra o tempo de in√≠cio

    // Tenta adivinhar a sequ√™ncia automaticamente at√© acertar ou o tempo acabar
    while (time(NULL) - start_time < 10) {  // Enquanto n√£o passar 10 segundos
        // Gera uma nova tentativa aleat√≥ria
        gerarSequencia(tentativa, TAM_SEQUENCIA);

        // Exibe a tentativa gerada para o jogador (opcional)
        printf(MAGENTA "Tentativa gerada: ");
        for (int i = 0; i < TAM_SEQUENCIA; i++) {
            printf("%d ", tentativa[i]);
        }
        printf("\n");

        // Verifica se a tentativa est√° correta
        int acerto = 1;
        for (int i = 0; i < TAM_SEQUENCIA; i++) {
            if (sequencia[i] != tentativa[i]) {
                acerto = 0;
                break;
            }
        }

        if (acerto) {
            acertou = 1;
            break;  // Se acertou, sai do loop
        }
    }

    if (acertou) {
        printf(GREEN "üéâ Parab√©ns, voc√™ acertou a sequ√™ncia! Voc√™ realizou o seu sonho!\n" RESET);
        limpar();
    } else {
        printf(RED "üí• Que pena, voc√™ errou a sequ√™ncia. Seu sonho ainda est√° distante...\n" RESET);
        limpar();
    }

    return acertou;
}
