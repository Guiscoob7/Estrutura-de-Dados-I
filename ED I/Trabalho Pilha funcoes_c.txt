//funcoes.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include "funcoes.h"

#define TAM_SEQUENCIA 4

// FunÃ§Ã£o para limpar a tela e aguardar a pressÃ£o de ENTER ğŸš¿â³
void limpar() 
{
    // ğŸ›‘ Solicita ao usuÃ¡rio para pressionar ENTER e limpar a tela
    printf("\n\n%sğŸ›‘ %sPressione ENTER para continuar... %sğŸ›‘%s: ", LIGHT_CYAN, LIGHT_YELLOW, LIGHT_CYAN, RESET);
    getchar();  // â³ Espera a entrada do usuÃ¡rio
    #ifdef _WIN32
        system("cls");  // ğŸ–¥ï¸ Comando especÃ­fico para Windows para limpar a tela
    #else
        system("clear");  // ğŸ Comando especÃ­fico para Linux/Mac para limpar a tela
    #endif
}

void limparImediato()
{
    #ifdef _WIN32
        system("cls");  // ğŸ–¥ï¸ Comando especÃ­fico para Windows para limpar a tela
    #else
        system("clear");  // ğŸ Comando especÃ­fico para Linux/Mac para limpar a tela
    #endif
}

// FunÃ§Ã£o para limpar o buffer de entrada ğŸ§¹
void limparbuffer() 
{
    int c;
    // ğŸ§¹ Remove todos os caracteres do buffer de entrada atÃ© o fim da linha ou o EOF
    while ((c = getchar()) != '\n' && c != EOF);
}

/*
ğŸ’» InstruÃ§Ãµes de execuÃ§Ã£o:
cd C:\Importante\C (caminho atÃ© a pasta em que se encontra o .exe)
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8 
.\programa.exe (nome do programa.exe)
*/

// FunÃ§Ã£o para exibir mensagens de boas-vindas sobre uma fila da morte âš°ï¸ğŸ’€
void boasVindas() 
{
    // Exibe uma borda superior da caixa de boas-vindas ğŸŒŒğŸ’¤
    printf("\n" BLUE BOLD "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" RESET "\n");
    // ğŸŒ™ğŸ’­ Mensagem de boas-vindas com destaque para a "Pilha dos Sonhos"
    printf(BLUE BOLD "â•‘" RESET " ğŸŒ™ğŸ’­ " BOLD BLUE "Bem-vindo Ã  " RESET BLUE BOLD "Pilha dos Sonhos" RESET BLUE BOLD " ğŸ’­ğŸŒ™ " BLUE BOLD "                                    â•‘" RESET "\n");
    // ğŸŒŒâœ¨ Mensagem sobre o poder dos sonhos
    printf(BLUE BOLD "â•‘" RESET " ğŸŒŒâœ¨ " LIGHT_YELLOW "Os sonhos sÃ£o a chave para a imaginaÃ§Ã£o, entre e descubra!" RESET BLUE BOLD " âœ¨ğŸŒŒ " BLUE BOLD "      â•‘" RESET "\n");
    // ğŸŒ ğŸ’¤ Mensagem sobre os sonhos que aguardam
    printf(BLUE BOLD "â•‘" RESET " ğŸŒ ğŸ’¤ " MAGENTA "Cada sonho aqui Ã© Ãºnico, prepare-se para se surpreender!" RESET BLUE BOLD " ğŸ’¤ğŸŒ  " BLUE BOLD "        â•‘" RESET "\n");
    // ğŸ’«ğŸŒ™ Mensagem sobre o mistÃ©rio dos sonhos
    printf(BLUE BOLD "â•‘" RESET " ğŸ’«ğŸŒ™ " GREEN "Mergulhe na sua mente e deixe os sonhos fluÃ­rem!" RESET BLUE BOLD " ğŸŒ™ğŸ’« " BLUE BOLD "                â•‘" RESET "\n");
    // Exibe uma borda inferior da caixa de boas-vindas ğŸŒŒğŸ’¤
    printf(BLUE BOLD "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" RESET "\n\n");
    limpar();
}

// FunÃ§Ã£o para exibir o menu principal com opÃ§Ãµes âš°ï¸ğŸ”ª
void exibeMenu() 
{
    printf(RED "\nğŸ•¯ï¸ğŸ’¤ Bem-vindo ao Gerenciador da Pilha de Sonhos ğŸ’¤ğŸ•¯ï¸\n\n" RESET);
    printf(YELLOW "ğŸ“œ Escolha seu destino:\n" RESET);
    printf(RED "ğŸŒŒ [1] - Adicionar Sonho\n" RESET);  
    printf(GREEN "ğŸŒ  [2] - Exibir Sonhos\n" RESET);  
    printf(BLUE "ğŸ” [3] - Consultar Sonho\n" RESET);  
    printf(CYAN "ğŸ—‘ï¸ [4] - Remover Sonho\n" RESET);  
    printf(MAGENTA "â³ [5] - Analisar Tempo da Pilha EstÃ¡tica\n" RESET);  
    printf(DOURADO "ğŸ“Š [6] - Analisar Tempo da Pilha DinÃ¢mica\n" RESET);  
    printf(RED "ğŸšª [7] - Realizar Sonho\n" RESET);  
    printf(YELLOW "ğŸ“ [8] - Sair do Gerenciador de Sonhos\n" RESET);  
    printf(YELLOW "\nğŸ‘‰ FaÃ§a sua escolha: " RESET);
}


pilhaDosSonhosEstatica* criarPilhaEstatica(void)
{
    pilhaDosSonhosEstatica *Ptp;
    Ptp = (pilhaDosSonhosEstatica*) malloc(sizeof(pilhaDosSonhosEstatica));
    if (Ptp != NULL)
        Ptp->topo = -1;
    return Ptp;
}

pilhaDosSonhosDinamica* criarPilhaDinamica(void){
    pilhaDosSonhosDinamica *Ptp = (pilhaDosSonhosDinamica*) malloc(sizeof(pilhaDosSonhosDinamica));
    if (Ptp != NULL)
        Ptp->topo = NULL;
    return Ptp;
}

int pilhaVaziaEstatica(pilhaDosSonhosEstatica* Ptp)
{
    if (Ptp == NULL)
        return -1;
    return Ptp->topo == -1;
}

int pilhaCheiaEstatica(pilhaDosSonhosEstatica* Ptp)
{
    if (Ptp == NULL)
        return -1;
    return Ptp->topo == MAX_PILHA-1;
}

int pilhaVaziaDinamica(pilhaDosSonhosDinamica* Ptp)
{
    if (Ptp == NULL)
        return -1;
    return Ptp->topo == NULL;
}

int pushPilhaEstatica(pilhaDosSonhosEstatica* Ptp, Sonho sonho)
{
    if (Ptp == NULL || pilhaCheiaEstatica(Ptp)) {
    printf("Erro: Pilha nula ou cheia. âŒ\n");
    return -1;
}

    Ptp->topo++;
    Ptp->sonho[Ptp->topo] = sonho;
    return 1;
}

int pushPilhaDinamica(pilhaDosSonhosDinamica* Ptp, Sonho sonho)
{
    if (Ptp == NULL)
        return -1;

    noDinamico* novoNo = (noDinamico*) malloc(sizeof(noDinamico));
    if (novoNo == NULL)
        return -1;

    novoNo->sonho = sonho;
    novoNo->prox = Ptp->topo;
    Ptp->topo = novoNo;
    return 1;
}

int popPilhaEstatica(pilhaDosSonhosEstatica* Ptp, Sonho* sonhoRemovido) {
    if (Ptp == NULL || pilhaVaziaEstatica(Ptp)) {
        return 0;
    }

    *sonhoRemovido = Ptp->sonho[Ptp->topo];
    Ptp->topo--;
    return 1;
}

int popPilhaDinamica(pilhaDosSonhosDinamica* Ptp, Sonho* sonhoRemovido) {
    if (Ptp == NULL || Ptp->topo == NULL) {
        return 0;
    }

    noDinamico* noRemovido = Ptp->topo;
    *sonhoRemovido = noRemovido->sonho;
    Ptp->topo = noRemovido->prox;

    free(noRemovido);
    return 1;
}

void exibirPilhaEstatica(pilhaDosSonhosEstatica* Ptp) {
    if (Ptp == NULL || pilhaVaziaEstatica(Ptp)) {
        printf(RED "\nğŸ’¤ A pilha estÃ¡ vazia ou nula.\n" RESET);
        return;
    }

    printf(LIGHT_CYAN BOLD "ğŸ“š ConteÃºdo da Pilha EstÃ¡tica:\n\n" RESET);
    for (int i = Ptp->topo; i >= 0; i--) {
        printf(LIGHT_YELLOW "ğŸŒŸ Sonho #%d:\n" RESET, i + 1);
        printf(PINK "  ğŸ”® Tipo: %s\n" RESET, Ptp->sonho[i].tipo);
        printf(LIME "  ğŸ’­ Intensidade Emocional: %d\n" RESET, Ptp->sonho[i].intensidadeEmocional);
        printf(CYAN "  ğŸ“œ DescriÃ§Ã£o: %s\n\n" RESET, Ptp->sonho[i].descricao);
    }
}

void exibirPilhaDinamica(pilhaDosSonhosDinamica* Ptp) {
    if (Ptp == NULL || Ptp->topo == NULL) {
        printf(RED "\nğŸ’¤ A pilha estÃ¡ vazia ou nula.\n" RESET);
        return;
    }

    printf(LIGHT_BLUE BOLD "ğŸ“š ConteÃºdo da Pilha DinÃ¢mica:\n\n" RESET);
    noDinamico* atual = Ptp->topo;
    int contador = 1;

    while (atual != NULL) {
        printf(LIGHT_GREEN "âœ¨ Sonho #%d:\n" RESET, contador);
        printf(PINK "  ğŸ”® Tipo: %s\n" RESET, atual->sonho.tipo);
        printf(LIME "  ğŸ’­ Intensidade Emocional: %d\n" RESET, atual->sonho.intensidadeEmocional);
        printf(CYAN "  ğŸ“œ DescriÃ§Ã£o: %s\n\n" RESET, atual->sonho.descricao);

        atual = atual->prox;  // Passa para o prÃ³ximo nÃ³
        contador++;
    }
}


int consultaTopoEstatica(pilhaDosSonhosEstatica* Ptp, Sonho *sonhos)
{
    if (Ptp->topo == -1) {  // Verifica se a pilha estÃ¡ vazia
        printf("âš ï¸ A pilha estÃ¡ vazia!\n");
        return 0;  // Retorna 0 para indicar que nÃ£o foi possÃ­vel consultar
    }

    *sonhos = Ptp->sonho[Ptp->topo];
    return 1;
}

int consultaTopoDinamica(pilhaDosSonhosDinamica* Ptp, Sonho* sonho)
{
    if (Ptp->topo == NULL) {  // Verifica se a pilha estÃ¡ vazia
        printf("âš ï¸ A pilha estÃ¡ vazia!\n");
        return 0;  // Retorna 0 para indicar que nÃ£o foi possÃ­vel consultar
    }

    *sonho = Ptp->topo->sonho;
    return 1;
}

void liberarPilhaEstatica (pilhaDosSonhosEstatica *Ptp)
{
    if (Ptp != NULL)
    {
        free(Ptp);
        printf(LIME "â™»ï¸ Pilha EstÃ¡tica liberada com sucesso!\n" RESET);
    }
}

void liberarPilhaDinamica (pilhaDosSonhosDinamica *Ptp)
{
    if (Ptp != NULL)
    {
        noDinamico *temp;
        while (Ptp->topo != NULL)
        {
            temp = Ptp->topo;
            Ptp->topo = Ptp->topo->prox;
            free(temp);
        }
    }
    free(Ptp);
    printf(AQUA "â™»ï¸ Pilha DinÃ¢mica liberada com sucesso!\n" RESET);
}

// FunÃ§Ã£o para gerar professores aleatÃ³rios com "crimes" engraÃ§ados
Sonho gerarSonhos()
{
    Sonho sonho;
    strcpy(sonho.tipo, "");
    strcpy(sonho.descricao, "");
    int max = 19;
    int min = 0;

    // Lista de tipos de sonhos
    char *tipos[] = {
        "Pesadelo com monstros",
        "Sonho de voar sem asas",
        "Sonho em que cai de uma grande altura",
        "Sonho de perder os dentes",
        "Sonho de ser perseguido por algo",
        "Sonho com um futuro alternativo",
        "Sonho com fogo e destruiÃ§Ã£o",
        "Sonho com pessoas falecidas",
        "Sonho em que se estÃ¡ preso em um lugar",
        "Sonho em que se ganha um prÃªmio inesperado",
        "Sonho com animais falantes",
        "Sonho de se tornar invisÃ­vel",
        "Sonho com uma festa mÃ¡gica",
        "Sonho de viajar para o passado",
        "Sonho com superpoderes",
        "Sonho de ser um herÃ³i",
        "Sonho com uma casa gigante",
        "Sonho de voar em um foguete",
        "Sonho em que se encontra um tesouro"};

    // Lista de descriÃ§Ãµes de sonhos
    char *descricoes[] = {
        "VocÃª estÃ¡ sendo perseguido por uma criatura monstruosa que aparece em cada canto.",
        "VocÃª comeÃ§a a flutuar no ar, como se estivesse voando, mas sem qualquer controle.",
        "VocÃª estÃ¡ em um prÃ©dio muito alto e, de repente, comeÃ§a a cair sem parar.",
        "De repente, vocÃª percebe que estÃ¡ perdendo todos os seus dentes, um por um.",
        "VocÃª corre desesperado, mas hÃ¡ algo ou alguÃ©m que te persegue sem parar.",
        "VocÃª acorda em um mundo paralelo, onde tudo Ã© muito diferente da sua realidade.",
        "O fogo toma conta de tudo ao seu redor, destruindo casas e Ã¡rvores, mas vocÃª nÃ£o consegue escapar.",
        "VocÃª encontra um ente querido, mas percebe que ele nÃ£o estÃ¡ mais entre os vivos.",
        "VocÃª tenta abrir a porta para sair, mas estÃ¡ trancado em uma sala sem saÃ­da.",
        "VocÃª encontra um bilhete que diz que vocÃª ganhou um prÃªmio enorme, mas ninguÃ©m mais parece saber de nada.",
        "VocÃª conversa com um cachorro que comeÃ§a a te contar segredos sobre o universo.",
        "VocÃª fica invisÃ­vel e comeÃ§a a observar todos ao seu redor, mas logo percebe que estÃ¡ perdido.",
        "VocÃª estÃ¡ em uma festa maravilhosa, cheia de pessoas que vocÃª nunca conheceu, mas se sente em casa.",
        "VocÃª consegue viajar no tempo e encontra um momento que vocÃª gostaria de reviver.",
        "VocÃª descobre que tem poderes especiais, como super forÃ§a ou teletransporte.",
        "VocÃª se vÃª salvando o mundo de um grande desastre e se torna um herÃ³i de verdade.",
        "VocÃª se perde em uma casa gigantesca, cheia de quartos e passagens secretas.",
        "VocÃª decola em um foguete, indo para o espaÃ§o e descobrindo planetas desconhecidos.",
        "VocÃª encontra um mapa antigo e comeÃ§a a procurar por um tesouro enterrado."};

    // Escolher tipo de sonho e descriÃ§Ã£o aleatÃ³rios
    strcpy(sonho.tipo, tipos[gerarNumeroAleatorio(min, max)]);
    sonho.intensidadeEmocional = gerarNumeroAleatorio(min, max); // Gera a intensidade emocional
    strcpy(sonho.descricao, descricoes[gerarNumeroAleatorio(min, max)]);

    return sonho;
}

// Gera dados aleatÃ³rios para um sonho ğŸ²ğŸŒ™
Sonho gerarDados()  
{
    Sonho sonho;
    gerarStringAleatoria(sonho.tipo, 22);  // Gera um tipo aleatÃ³rio para o sonho
    sonho.intensidadeEmocional = gerarNumeroAleatorio(1,100); // Gera a intensidade emocional
    gerarStringAleatoria(sonho.descricao, 44); // Gera uma descriÃ§Ã£o aleatÃ³ria para o sonho
    return sonho;
}

// Gera um caractere aleatÃ³rio (letra maiÃºscula ou minÃºscula) ğŸ²ğŸ” 
char gerarCaractereAleatorio() 
{
    int tipo = rand() % 2;
    if (tipo == 0) return 'a' + rand() % 26;
    else return 'A' + rand() % 26;
}

// Gera uma string aleatÃ³ria com tamanho especificado ğŸ²âœï¸
void gerarStringAleatoria(char *str, int tamanho) 
{
    for (int i = 0; i < tamanho; i++)
        str[i] = gerarCaractereAleatorio();
    str[tamanho - 1] = '\0';  // Corrige a posiÃ§Ã£o do terminador nulo
}

// Gera um nÃºmero aleatÃ³rio entre 1 e 100 ğŸ²ğŸ”¢
int gerarNumeroAleatorio(int min, int max) 
{
    return rand() % (max - min + 1) + min;
}

void analisePilhaEstatica(pilhaDosSonhosEstatica *pilha, Sonho *sonho, double* tempos) {
    double start, finish;
    int cont = 0;
    int entradas[] = {1000, 3000, 5000, 10000, 25000};

    for (int i = 0; i < 5; i++) {
        // Medindo o tempo de inserÃ§Ã£o
        start = (double) clock();
        for (int j = 0; j < entradas[i]; j++) {
            pushPilhaEstatica(pilha, gerarDados()); // Insere um sonho na pilha
        }
        finish = (double) clock();
        tempos[cont++] = finish - start; // Armazenando o tempo de inserÃ§Ã£o

        // Medindo o tempo de exibiÃ§Ã£o
        start = (double) clock();
        exibirPilhaEstatica(pilha); // Exibe os sonhos na pilha
        finish = (double) clock();
        tempos[cont++] = finish - start; // Armazenando o tempo de exibiÃ§Ã£o

        // Medindo o tempo de remoÃ§Ã£o
        start = (double) clock();
        for (int j = 0; j < entradas[i]; j++) {
            popPilhaEstatica(pilha, sonho); // Remove um sonho da pilha
        }
        finish = (double) clock();
        tempos[cont++] = finish - start; // Armazenando o tempo de remoÃ§Ã£o
    }
}

void analisePilhaDinamica(pilhaDosSonhosDinamica *pilha, Sonho *sonho, double* tempos) {
    double start, finish;
    int cont = 0;
    int entradas[] = {1000, 3000, 5000, 10000, 25000};

    for (int i = 0; i < 5; i++) {
        // Medindo o tempo de inserÃ§Ã£o
        start = (double) clock();
        for (int j = 0; j < entradas[i]; j++) {
            pushPilhaDinamica(pilha, gerarDados()); // Insere um sonho na pilha
        }
        finish = (double) clock();
        tempos[cont++] = finish - start; // Armazenando o tempo de inserÃ§Ã£o

        // Medindo o tempo de exibiÃ§Ã£o
        start = (double) clock();
        exibirPilhaDinamica(pilha); // Exibe os sonhos na pilha
        finish = (double) clock();
        tempos[cont++] = finish - start; // Armazenando o tempo de exibiÃ§Ã£o

        // Medindo o tempo de remoÃ§Ã£o
        start = (double) clock();
        for (int j = 0; j < entradas[i]; j++) {
            popPilhaDinamica(pilha, sonho); // Remove um sonho da pilha
        }
        finish = (double) clock();
        tempos[cont++] = finish - start; // Armazenando o tempo de remoÃ§Ã£o
    }
}

// FunÃ§Ã£o para gerar uma sequÃªncia de nÃºmeros aleatÃ³rios
void gerarSequencia(int *sequencia, int tamanho) {
    for (int i = 0; i < tamanho; i++) {
        sequencia[i] = rand() % 10; // NÃºmeros de 0 a 9
    }
}

// FunÃ§Ã£o para exibir a sequÃªncia de nÃºmeros por um curto perÃ­odo
void exibirSequencia(int *sequencia, int tamanho) {
    printf(GREEN "âœ¨ A sequÃªncia dos seus sonhos serÃ¡ exibida por 3 segundos! Lembre-se bem...\n\n" RESET);
    printf("\t\t");
    for (int i = 0; i < tamanho; i++) {
        printf(YELLOW "%d " RESET, sequencia[i]);
    }
    printf("\n");

    sleep(3);  // Espera 3 segundos para o jogador memorizar

    limparImediato();
    printf(RED "\nğŸ’¥ A sequÃªncia desapareceu! VocÃª tem 10 segundos para adivinhar... Vamos lÃ¡!\n" RESET);
}

// FunÃ§Ã£o para desafiar o jogador a adivinhar a sequÃªncia
int realizarSonho() {
    int sequencia[TAM_SEQUENCIA];
    int tentativa[TAM_SEQUENCIA];
    int acertou = 0;

    srand(time(NULL));  // Inicializa o gerador de nÃºmeros aleatÃ³rios

    // Gera a sequÃªncia dos sonhos
    gerarSequencia(sequencia, TAM_SEQUENCIA);

    // Exibe a sequÃªncia para o jogador por um curto tempo
    exibirSequencia(sequencia, TAM_SEQUENCIA);

    // Espera 10 segundos para o jogador tentar adivinhar
    printf(CYAN "\nâ³ VocÃª tem 10 segundos para tentar adivinhar a sequÃªncia dos seus sonhos. Comece agora!\n" RESET);
    sleep(1);  // Pequena pausa antes de comeÃ§ar

    time_t start_time = time(NULL);  // Registra o tempo de inÃ­cio

    // Tenta adivinhar a sequÃªncia automaticamente atÃ© acertar ou o tempo acabar
    while (time(NULL) - start_time < 10) {  // Enquanto nÃ£o passar 10 segundos
        // Gera uma nova tentativa aleatÃ³ria
        gerarSequencia(tentativa, TAM_SEQUENCIA);

        // Exibe a tentativa gerada para o jogador (opcional)
        printf(MAGENTA "Tentativa gerada: ");
        for (int i = 0; i < TAM_SEQUENCIA; i++) {
            printf("%d ", tentativa[i]);
        }
        printf("\n");

        // Verifica se a tentativa estÃ¡ correta
        int acerto = 1;
        for (int i = 0; i < TAM_SEQUENCIA; i++) {
            if (sequencia[i] != tentativa[i]) {
                acerto = 0;
                break;
            }
        }

        if (acerto) {
            acertou = 1;
            break;  // Se acertou, sai do loop
        }
    }

    if (acertou) {
        printf(GREEN "ğŸ‰ ParabÃ©ns, vocÃª acertou a sequÃªncia! VocÃª realizou o seu sonho!\n" RESET);
        limpar();
    } else {
        printf(RED "ğŸ’¥ Que pena, vocÃª errou a sequÃªncia. Seu sonho ainda estÃ¡ distante...\n" RESET);
        limpar();
    }

    return acertou;
}
