#include "funcoes.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Fun√ß√£o para limpar a tela e solicitar ao usu√°rio pressionar ENTER para continuar
void limpar() {
    // Mensagem para o usu√°rio
    printf("\n\n%süõë %sPressione ENTER para continuar... %süõë%s: ", LIGHT_CYAN, LIGHT_YELLOW, LIGHT_CYAN, RESET);

    // Pausa at√© o usu√°rio pressionar ENTER
    getchar();

    #ifdef _WIN32
        system("cls");  // Comando para Windows
    #else
        system("clear");  // Comando para Unix/Linux
    #endif
}

// Fun√ß√£o para limpar o buffer de entrada, removendo caracteres extras
void limparbuffer() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF);
}

Ingresso* Libera_lista(Ingresso* Ptl){
    Ingresso *atual = Ptl;
    Ingresso *proximoNo;
    // Se a lista estiver vazia, n√£o h√° nada a liberar
    if (Ptl == NULL)
        return NULL;   
    // Libera todos os elementos da lista
    while (atual != NULL) {
        proximoNo = atual->prox;
        free(atual);
        atual = proximoNo;
    }
    return NULL; // Ptl = NULL; return Ptl;
}

Ingresso *Cria_lista(void) {
    // Cria uma lista vazia
    return NULL;
}

int E_vazia(Ingresso *Ptl) {
    // Verifica se a lista est√° vazia
    if (Ptl == NULL)
        return 1;
    return 0;
}

void Exibir_lista(Ingresso *Ptl, char* filme, int* flag) {
    // Verifica se a lista est√° vazia
    if (E_vazia(Ptl) == 1) {
        printf("%s%süîç %sA lista est√° vazia! Nada para exibir.%s\n", LIGHT_BLUE, BOLD, RESET, RESET);
        return;
    }
    Ingresso *aux = Ptl;
    int cont = 0;
    // Exibe todos os elementos da lista relacionados ao filme
    printf("%s%süé¨ %sLista de Ingressos para o filme %s: %s\n", MAGENTA, BOLD, RESET, RESET, filme);
    while (aux != NULL) {
        // Imprime o n√∫mero e nome do filme se corresponder ao filme fornecido
        if (strcasecmp(aux->filme, filme) == 0){
            *flag = 1;
            printf("\n%s%s%d. %s%s%s\n", LIGHT_GREEN, BOLD, ++cont, LIGHT_YELLOW, aux->filme, RESET);
            // Imprime o n√∫mero do assento
            printf("   %süéüÔ∏è N¬∫ Assento: %s%d%s\n", GREEN, BOLD, aux->assento, RESET);
        }
        aux = aux->prox;
    }
    if (*flag)
        printf("\n%s%s‚ú® Fim da lista! ‚ú®%s\n", MAGENTA, BOLD, RESET);
    else
        printf("\n%s%süö´ Nenhum filme encontrado!%s\n", YELLOW, BOLD, RESET);
}

void Exibir_lista_total(Ingresso *Ptl) {
    // Verifica se a lista est√° vazia
    if (E_vazia(Ptl) == 1) {
        printf("%s%süîç %sA lista est√° vazia! Nada para exibir.%s\n", LIGHT_BLUE, BOLD, RESET, RESET);
        return;
    } 
    Ingresso *aux = Ptl;
    int cont = 0;
    // Exibe todos os elementos da lista
    printf("%s%süé¨ %sLista de Ingressos%s:%s\n", MAGENTA, BOLD, RESET, ORANGE, RESET);
    while (aux != NULL) {
        // Imprime o n√∫mero e nome do filme
        printf("\n%s%s%d. %s%s%s\n", LIGHT_GREEN, BOLD, ++cont, LIGHT_YELLOW, aux->filme, RESET);
        // Imprime o n√∫mero do assento
        printf("   %süéüÔ∏è N¬∫ Assento: %s%d%s\n", GREEN, BOLD, aux->assento, RESET);
        aux = aux->prox;
    }
    printf("\n%s%s‚ú® Fim da lista! ‚ú®%s\n", MAGENTA, BOLD, RESET);
}

Ingresso* Remove_elem(Ingresso* Ptl, int elem, char* filme, int *flag) {
    // Verifica se o n√∫mero do ingresso √© v√°lido
    if (elem < 1 || elem > 10) {
        printf("%s‚ö†Ô∏è Erro: N√∫mero de Ingresso inv√°lido!%s\n", RED, RESET);
        *flag = 0;
        return Ptl;
    }
    // Remove o elemento da lista
    if (Ptl == NULL) {
        printf("%süîç A lista j√° est√° vazia!%s\n", YELLOW, RESET);
        *flag = 0;
        return Ptl;
    }

    Ingresso *atual, *aux;

    atual = Ptl;
    // Procura o elemento a ser removido
    while (atual != NULL && (atual->assento != elem || (strcasecmp(atual->filme, filme) != 0))) {
        atual = atual->prox;
    }
    // Se o elemento n√£o for encontrado
    if (atual == NULL) {
        printf("%s‚ö†Ô∏è Erro: N√∫mero de Ingresso n√£o dispon√≠vel!%s\n", RED, RESET);
        *flag = 0;
        return Ptl;
    }
    // Se o elemento a ser removido √© o √∫nico da lista
    if (atual == Ptl && atual->prox == NULL){
      free(atual);
      *flag = 1;
      return Ptl;
    }

    // Ajusta os ponteiros para remover o elemento
    if (atual == Ptl)
      Ptl = atual->prox;
    else
      atual->ant->prox = atual->prox;

    if (atual->prox != NULL)
      atual->prox->ant = atual->ant;

    free(atual);
  
    *flag = 1;
    return Ptl;  
}

/*
cd C:\Importante\C
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
.\programa.exe
*/

// Fun√ß√£o para exibir mensagens de boas-vindas
void boasVindas() {
    printf("\n" ORANGE BOLD "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" RESET "\n");
    printf(ORANGE BOLD "‚ïë" RESET " üé•üçø " RED BOLD "Bem-vindo ao " RESET MAGENTA "Programa de Cinema" ORANGE " üçøüé• " ORANGE BOLD "                               ‚ïë" RESET "\n");
    printf(ORANGE BOLD "‚ïë" RESET " üåüüé¨ " YELLOW "Descubra os melhores filmes e ingressos!" ORANGE " üé¨üåü " ORANGE BOLD "                      ‚ïë" RESET "\n");
    printf(ORANGE BOLD "‚ïë" RESET " üå†üé• " GREEN "Que a divers√£o comece agora!" ORANGE " üé•üå† " ORANGE BOLD "                                  ‚ïë" RESET "\n");
    printf(ORANGE BOLD "‚ïë" RESET " üååüçø " MAGENTA "Vamos explorar o mundo do cinema juntos!" ORANGE " üçøüåå " ORANGE BOLD "                      ‚ïë" RESET "\n");
    printf(ORANGE BOLD "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" RESET "\n\n");
}

Ingresso* Insere_elem(Ingresso* Ptl, int num, char *filme) {
    Ingresso *Ptno;
    // Aloca mem√≥ria para um novo ingresso
    Ptno = (Ingresso*)malloc(sizeof(Ingresso));
    if (Ptno == NULL){
        return Ptl;
    }
    Ptno->assento = num;
    strcpy(Ptno->filme, filme);
    Ptno->prox = NULL;
    // Se a lista estiver vazia, o novo ingresso ser√° o primeiro
    if (Ptl == NULL){
      Ptno->ant = NULL;
      return Ptno;
    }
    Ingresso *aux = Ptl;
    // Encontra o final da lista
    while (aux->prox != NULL)
      aux = aux->prox;

    Ptno->ant = aux;
    aux->prox = Ptno;
    return Ptl;
}

Ingresso* inicializarFilmes(Ingresso *lista) {

    // Adiciona filmes √† lista
    lista = Insere_elem(lista, 1, "Daniele no Mundo");
    lista = Insere_elem(lista, 3, "Daniele no Mundo");
    lista = Insere_elem(lista, 2, "Daniele no Mundo");
    lista = Insere_elem(lista, 4, "Daniele e o Valor");
    lista = Insere_elem(lista, 5, "Daniele e o Valor");
    lista = Insere_elem(lista, 6, "Filme da Daniele");
    lista = Insere_elem(lista, 7, "Filme da Daniele");
    lista = Insere_elem(lista, 8, "Daniele e Guardi√µes");
    lista = Insere_elem(lista, 9, "Daniele e Aventura");
    lista = Insere_elem(lista, 10, "Daniele e Destino");

    return lista;
}

Ingresso* Dividir_Lista (Ingresso* Ptl){
    // Se a lista estiver vazia ou tiver apenas um elemento, retorna a pr√≥pria lista
    if (!Ptl || !Ptl->prox)
        return Ptl;
    
    Ingresso* Anda_2 = Ptl;
    Ingresso* Anda_1 = Ptl;
    Ingresso* Anterior = NULL;

    // Encontra o meio da lista
    while (Anda_2 && Anda_2->prox){
        Anda_2 = Anda_2->prox->prox;
        Anterior = Anda_1;
        Anda_1 = Anda_1->prox;
    }

    // Ajusta o ponteiro do final da primeira metade
    if (Anterior)
        Anterior->prox = NULL;
    
    // Ajusta o ponteiro do in√≠cio da segunda metade
    if(Anda_1)
        Anda_1->ant = NULL;

    return Anda_1;
}

Ingresso* Juntar_Lista(Ingresso* Esquerda, Ingresso* Direita){
    Ingresso Inutil;
    Ingresso* Cabeca = &Inutil;
    Inutil.prox = NULL;
    Inutil.ant = NULL;

    // Junta as duas metades ordenadas
    while (Esquerda && Direita){
        if(Esquerda->assento < Direita->assento){
            Cabeca->prox = Esquerda;
            Esquerda->ant = Cabeca;
            Esquerda = Esquerda->prox;
        }
        else{
            Cabeca->prox = Direita;
            Direita->ant = Cabeca;
            Direita = Direita->prox;
        }
        Cabeca = Cabeca->prox;
    }
    Cabeca->prox = (Esquerda) ? Esquerda : Direita;
    if(Cabeca->prox)
        Cabeca->prox->ant = Cabeca;

    return Inutil.prox;
}

Ingresso* Ordenar(Ingresso* Cabeca){
    // Se a lista estiver vazia ou tiver um √∫nico elemento, retorna a pr√≥pria lista
    if (!Cabeca || !Cabeca->prox)
        return Cabeca;

    // Divide a lista em duas metades, ordena e junta as duas metades
    Ingresso* Meio = Dividir_Lista(Cabeca);
    Ingresso* Esquerda = Ordenar(Cabeca);
    Ingresso* Direita = Ordenar(Meio);

    return Juntar_Lista(Esquerda, Direita);
}
