//funcoes.h

// Definindo c√≥digos de cor ANSI para formata√ß√£o do texto no terminal
// Estes c√≥digos s√£o usados para alterar a cor e estilo do texto exibido no terminal

#define RESET "\033[0m"           // C√≥digo para resetar as configura√ß√µes de cor e estilo para o padr√£o
#define BOLD "\033[1m"            // C√≥digo para aplicar negrito ao texto
#define UNDERLINE "\033[4m"       // C√≥digo para sublinhar o texto
#define GREEN "\033[32m"          // C√≥digo para texto na cor verde
#define YELLOW "\033[33m"         // C√≥digo para texto na cor amarelo
#define CYAN "\033[36m"           // C√≥digo para texto na cor ciano
#define MAGENTA "\033[35m"        // C√≥digo para texto na cor magenta
#define RED "\033[31m"            // C√≥digo para texto na cor vermelho
#define BLUE "\033[34m"           // C√≥digo para texto na cor azul
#define LIGHT_BLUE  "\033[94m"    // C√≥digo para texto na cor azul claro
#define LIGHT_YELLOW  "\033[93m"  // C√≥digo para texto na cor amarelo claro
#define LIGHT_CYAN   "\033[96m"   // C√≥digo para texto na cor ciano claro
#define LIGHT_GREEN   "\033[92m"  // C√≥digo para texto na cor verde claro     
#define PURPLE "\x1B[35m"         // C√≥digo para texto na cor roxo
#define ORANGE "\033[38;5;208m"   // C√≥digo para texto na cor laranja
#define DOURADO "\033[1;33m"      // C√≥digo para texto na cor dourado
#define BLACK "\033[0;30m"        // C√≥digo para texto na cor preto

// Estrutura principal que representa um Emoji
struct emoji {                
  struct emoji *prox;  // Ponteiro para o pr√≥ximo Emoji na lista 
  struct emoji *ant;   // Ponteiro para o emoji anterior na lista
  char simbolo[16];    // Representa o s√≠mbolo ou nome do emoji (m√°ximo de 15 caracteres + null terminator)
  int popularidade;    // Popularidade do emoji (ou qualquer outra m√©trica usada para ordena√ß√£o)
};

// Define o tipo `Emoji` como uma forma simplificada de usar a struct `emoji`
typedef struct emoji Emoji; 

// Estrutura para representar a lista duplamente encadeada de Emojis
struct listaDuplamenteEncadeada {
  Emoji* cabeca;       // Ponteiro para o primeiro emoji da lista
  Emoji* cauda;        // Ponteiro para o √∫ltimo emoji da lista
};

// Define o tipo `ListaDuplamenteEncadeada` como uma forma simplificada de usar a struct `listaDuplamenteEncadeada`
typedef struct listaDuplamenteEncadeada ListaDuplamenteEncadeada; 

// Fun√ß√£o para limpar a tela e solicitar ao usu√°rio pressionar ENTER para continuar
void limpar(); 
// Esta fun√ß√£o exibe uma mensagem solicitando ao usu√°rio pressionar ENTER para continuar,
// e ap√≥s a entrada, limpa a tela com o comando apropriado para o sistema operacional.

// Fun√ß√£o para limpar o buffer de entrada, removendo caracteres extras
void limparbuffer(); 
// Esta fun√ß√£o esvazia o buffer de entrada para evitar problemas ao processar entradas de m√∫ltiplos caracteres.

// Fun√ß√£o para remover Emoji(s) da lista com a popularidade especificada
Emoji* Remove_elem(Emoji* Ptl, int popularidade);
// Esta fun√ß√£o percorre a lista de emojis e remove todos os emojis que possuem a popularidade igual √† especificada.
// A fun√ß√£o retorna o ponteiro para a cabe√ßa da lista ap√≥s as remo√ß√µes.

// Fun√ß√£o para liberar a mem√≥ria alocada para a lista de Emojis
Emoji *Libera_lista(Emoji *Ptl);
// Esta fun√ß√£o percorre a lista e libera a mem√≥ria alocada para cada n√≥, prevenindo vazamentos de mem√≥ria.
// Define a cauda como NULL ap√≥s a libera√ß√£o.

// Fun√ß√£o para exibir uma mensagem de boas-vindas
void boasVindas();
// Exibe uma mensagem estilizada de boas-vindas ao usu√°rio, utilizando cores e emojis para uma apresenta√ß√£o atraente.

// Fun√ß√£o para trocar os dados de dois n√≥s
void trocar(Emoji* a, Emoji* b);
// Esta fun√ß√£o troca os dados (popularidade e s√≠mbolo) entre dois emojis fornecidos como par√¢metros.

// Fun√ß√£o de ordena√ß√£o Stooge Sort para listas duplamente encadeadas
void stoogeSort(ListaDuplamenteEncadeada* Ptl, Emoji *l, Emoji *h);
// Implementa o algoritmo Stooge Sort para ordenar uma lista duplamente encadeada de emojis.
// A ordena√ß√£o √© feita recursivamente em tr√™s partes da lista: in√≠cio at√© um ter√ßo, primeiro ter√ßo at√© final, e in√≠cio at√© dois ter√ßos.

// Fun√ß√£o para ordenar a lista usando Stooge Sort e exibir o resultado
void ordenarLista(ListaDuplamenteEncadeada* Ptl);
// Chama a fun√ß√£o `stoogeSort` para ordenar a lista de emojis e, em seguida, exibe a lista ordenada.
// Inclui mensagens antes e depois da ordena√ß√£o e limpa a tela para melhor visualiza√ß√£o.




//funcoes.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "funcoes.h"

// Fun√ß√£o para limpar a tela e aguardar a press√£o de ENTER
void limpar() {
    // Solicita ao usu√°rio para pressionar ENTER e limpar a tela
    printf("\n\n%süõë %sPressione ENTER para continuar... %süõë%s: ", LIGHT_CYAN, LIGHT_YELLOW, LIGHT_CYAN, RESET);
    getchar();  // Espera a entrada do usu√°rio
    #ifdef _WIN32
        system("cls");  // Comando espec√≠fico para Windows para limpar a tela
    #else
        system("clear");  // Comando espec√≠fico para Linux/Mac para limpar a tela
    #endif
}

// Fun√ß√£o para limpar o buffer de entrada
void limparbuffer() {
    int c;
    // Remove todos os caracteres do buffer de entrada at√© o fim da linha ou o EOF
    while ((c = getchar()) != '\n' && c != EOF);
}

// Fun√ß√£o para remover emojis com uma determinada popularidade
Emoji* Remove_elem(ListaDuplamenteEncadeada* Ptl, int popularidade, int *flag) {
    Emoji* atual = Ptl->cabeca;  // Inicia da cabe√ßa da lista
    Emoji* aux;
    *flag = 0;  // Inicializa a flag de remo√ß√£o como 0 (nenhum emoji removido ainda)

    // Percorre a lista procurando emojis com a popularidade especificada
    while (atual != NULL) {
        if (atual->popularidade == popularidade) {
            printf(BLUE "üóëÔ∏è Removendo emoji(s) com popularidade %d...\n\n" RESET, popularidade);
            
            // Ajusta os ponteiros da lista duplamente encadeada para remover o emoji
            if (atual == Ptl->cabeca) {
                Ptl->cabeca = atual->prox;  // Atualiza a cabe√ßa da lista
                if (Ptl->cabeca != NULL) {
                    Ptl->cabeca->ant = NULL;  // Atualiza o ponteiro anterior da nova cabe√ßa
                }
            } else {
                atual->ant->prox = atual->prox;  // Atualiza o pr√≥ximo do n√≥ anterior
                if (atual->prox != NULL) {
                    atual->prox->ant = atual->ant;  // Atualiza o anterior do n√≥ pr√≥ximo
                }
            }
            if (atual == Ptl->cauda) {
                Ptl->cauda = atual->ant;  // Atualiza a cauda da lista
            }

            // Libera a mem√≥ria do emoji removido
            aux = atual;
            atual = atual->prox;
            free(aux);

            *flag = 1;  // Atualiza a flag indicando que um emoji foi removido
            printf(GREEN "‚úÖ Emoji(s) com popularidade %d removido com sucesso!\n" RESET, popularidade);
        } else {
            atual = atual->prox;  // Move para o pr√≥ximo emoji
        }
    }

    // Mensagem se nenhum emoji com a popularidade especificada foi encontrado
    if (*flag == 0) {
        printf(YELLOW "‚ùå Nenhum emoji com popularidade %d encontrado para remo√ß√£o.\n" RESET, popularidade);
    }

    return Ptl->cabeca;  // Retorna a nova cabe√ßa da lista
}

// Fun√ß√£o para consultar um emoji pelo s√≠mbolo
int Consulta_elem(ListaDuplamenteEncadeada* Ptl, const char* emoji) {
    Emoji* atual = Ptl->cabeca;  // Inicia da cabe√ßa da lista

    // Percorre a lista procurando o emoji com o s√≠mbolo especificado
    while (atual != NULL && strcmp(atual->simbolo, emoji) != 0) {
        atual = atual->prox;
    }

    // Verifica se o emoji foi encontrado
    if (atual == NULL) {
        printf("%süíîüò¢ %sEmoji n√£o encontrado! %süò≠üíß %s\n", RED, CYAN, BLUE, RESET);
        return 0;  // Retorna 0 se o emoji n√£o foi encontrado
    } else {
        printf("%süòä‚≠ê %sEmoji encontrado com sucesso! %süéâ‚≠ê %s\n\n", RED, GREEN, BLUE, RESET);
        // Exibe detalhes do emoji encontrado
        printf("%süåüüî• %sEmoji: |------[%s]------| %süöÄüåà %s\n", RED, CYAN, atual->simbolo, MAGENTA, RESET);
        printf("%süí•üí´ %sPopularidade: %d %s‚ö°üåª %s\n\n", YELLOW, BLUE, atual->popularidade, MAGENTA, RESET);
        return 1;  // Retorna 1 se o emoji foi encontrado
    }
}

// Fun√ß√£o para liberar toda a mem√≥ria usada pela lista
Emoji* Libera_lista(ListaDuplamenteEncadeada* Ptl) {
    Emoji* aux = Ptl->cabeca;  // Inicia da cabe√ßa da lista

    // Percorre a lista liberando a mem√≥ria de cada emoji
    while (aux != NULL) {
        Emoji* temp = aux;
        aux = aux->prox;
        free(temp);
    }

    Ptl->cauda = NULL;  // Define a cauda como NULL ap√≥s a libera√ß√£o da mem√≥ria
    return Ptl->cabeca;  // Retorna a nova cabe√ßa da lista (que deve ser NULL)
}

// Fun√ß√£o para trocar os dados de dois emojis
void trocar(Emoji* a, Emoji* b) {
    int tempPopularidade = a->popularidade;  // Armazena a popularidade de 'a' temporariamente
    char tempSimbolo[16];
    strcpy(tempSimbolo, a->simbolo);  // Armazena o s√≠mbolo de 'a' temporariamente

    a->popularidade = b->popularidade;  // Troca a popularidade de 'a' com 'b'
    strcpy(a->simbolo, b->simbolo);  // Troca o s√≠mbolo de 'a' com 'b'

    b->popularidade = tempPopularidade;  // Define a popularidade de 'b' para o valor original de 'a'
    strcpy(b->simbolo, tempSimbolo);  // Define o s√≠mbolo de 'b' para o valor original de 'a'
}

// Fun√ß√£o de ordena√ß√£o Stooge Sort para a lista de emojis
void stoogeSort(ListaDuplamenteEncadeada* Ptl, Emoji* l, Emoji* h) {
    // Verifica se a lista √© pequena demais para ordenar
    // Caso base: a lista √© vazia, possui um √∫nico elemento, ou l e h s√£o o mesmo n√≥
    // ou l e h s√£o adjacentes (isto √©, l est√° imediatamente antes de h)
    if (l == NULL || h == NULL || l == h || l->prox == h) return;

    // Verifica se √© necess√°rio trocar os emojis para garantir que 'l' esteja antes de 'h'
    // Se a popularidade do emoji 'l' for maior do que a de 'h', troca os dados dos emojis
    if (l->popularidade > h->popularidade) {
        trocar(l, h);  // Chama a fun√ß√£o 'trocar' para trocar os dados dos emojis
    }

    // Calcula o tamanho da sublista de emojis entre l e h
    int tamanho = 1;  // Inicializa o tamanho com 1 porque l √© um elemento
    Emoji* temp = l;
    // Percorre a sublista para contar o n√∫mero total de elementos
    while (temp != h) {
        tamanho++;
        temp = temp->prox;  // Move para o pr√≥ximo elemento na lista
    }

    // Divide a lista em tr√™s partes e aplica o Stooge Sort recursivamente
    // O algoritmo Stooge Sort divide a lista em tr√™s partes iguais e ordena as duas partes externas
    // e a parte central
    if (tamanho > 2) {  // S√≥ divide se o tamanho da lista for maior que 2
        int umTerco = tamanho / 3;  // Calcula o tamanho de um ter√ßo da lista

        // Determina o in√≠cio do primeiro ter√ßo da sublista
        Emoji* primeiroTerco = l;
        for (int i = 0; i < umTerco; i++) {
            if (primeiroTerco != NULL) primeiroTerco = primeiroTerco->prox;  // Avan√ßa um ter√ßo da lista
        }

        // Determina o in√≠cio do segundo ter√ßo da sublista, come√ßando do final e indo para tr√°s
        Emoji* doisTerco = h;
        for (int i = 0; i < umTerco; i++) {
            if (doisTerco != NULL) doisTerco = doisTerco->ant;  // Retrocede um ter√ßo da lista
        }

        // Aplica o Stooge Sort recursivamente nas tr√™s partes da lista
        // Ordena a sublista do in√≠cio at√© o final do segundo ter√ßo
        if (primeiroTerco != NULL) stoogeSort(Ptl, l, doisTerco);
        // Ordena a sublista do in√≠cio do primeiro ter√ßo at√© o final
        if (primeiroTerco != NULL && doisTerco != NULL) stoogeSort(Ptl, primeiroTerco, h);
        // Ordena novamente a sublista do in√≠cio at√© o final do segundo ter√ßo
        if (primeiroTerco != NULL) stoogeSort(Ptl, l, doisTerco);
    }
}


// Fun√ß√£o para ordenar a lista de emojis
void ordenarLista(ListaDuplamenteEncadeada* Ptl) {
    if (Ptl->cabeca && Ptl->cauda) {
        printf(CYAN "üîÑ Lista Inicial:\n" RESET);
        ExibirLista(Ptl);  // Exibe a lista inicial (ainda a ser implementado)
        printf("\n");

        limpar();  // Limpa a tela

        printf(YELLOW "üöÄ Iniciando a ordena√ß√£o com Stooge Sort...\n\n" RESET);
        stoogeSort(Ptl, Ptl->cabeca, Ptl->cauda);  // Ordena a lista usando Stooge Sort

        printf(GREEN "‚úÖ Lista Ordenada:\n" RESET);
        ExibirLista(Ptl);  // Exibe a lista ordenada (ainda a ser implementado)
        printf("\n");
    } else {
        printf(RED "‚ùå A lista est√° vazia ou n√£o est√° corretamente inicializada.\n" RESET);
    }
}


/*
Maria isso deve ser executado no power shell para rodar emoji
cd C:\Importante\C (caminho at√© a pasta em que se encontra o .exe)
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8 
.\programa.exe (nome do programa.exe)
*/

// Fun√ß√£o para exibir mensagens de boas-vindas sobre uma lista de emojis
void boasVindas() {
    // Exibe uma borda superior da caixa de boas-vindas
    printf("\n" GREEN BOLD "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" RESET "\n");
    // Mensagem de boas-vindas com destaque para a "Lista de Emojis"
    printf(GREEN BOLD "‚ïë" RESET " üåüüéâ " BOLD GREEN "Bem-vindo √† " RESET GREEN BOLD "Lista de Emojis do Zap" RESET GREEN BOLD " üéâüåü " GREEN BOLD "                              ‚ïë" RESET "\n");
    // Mensagem sobre explorar emojis
    printf(GREEN BOLD "‚ïë" RESET " üòÄüòç " YELLOW "Explore uma sele√ß√£o divertida de emojis para usar!" RESET GREEN BOLD " üòçüòÄ " GREEN BOLD "              ‚ïë" RESET "\n");
    // Mensagem sobre escolher √≠cones e express√µes
    printf(GREEN BOLD "‚ïë" RESET " üé®üñºÔ∏è " MAGENTA "Escolha entre uma variedade de √≠cones e express√µes!" RESET GREEN BOLD " üñºÔ∏èüé® " GREEN BOLD "             ‚ïë" RESET "\n");
    // Mensagem sobre personaliza√ß√£o com emojis
    printf(GREEN BOLD "‚ïë" RESET " üõ†Ô∏è‚ú® " GREEN "Personalize suas mensagens com emojis √∫nicos!" RESET GREEN BOLD " ‚ú®üõ†Ô∏è " GREEN BOLD "                   ‚ïë" RESET "\n");
    // Exibe uma borda inferior da caixa de boas-vindas
    printf(GREEN BOLD "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" RESET "\n\n");
}