//funcoes.h

// Definindo cÃ³digos de cor ANSI para formataÃ§Ã£o do texto no terminal
// Estes cÃ³digos sÃ£o usados para alterar a cor e estilo do texto exibido no terminal

#define RESET "\033[0m"           // CÃ³digo para resetar as configuraÃ§Ãµes de cor e estilo para o padrÃ£o
#define BOLD "\033[1m"            // CÃ³digo para aplicar negrito ao texto
#define UNDERLINE "\033[4m"       // CÃ³digo para sublinhar o texto
#define GREEN "\033[32m"          // CÃ³digo para texto na cor verde
#define YELLOW "\033[33m"         // CÃ³digo para texto na cor amarelo
#define CYAN "\033[36m"           // CÃ³digo para texto na cor ciano
#define MAGENTA "\033[35m"        // CÃ³digo para texto na cor magenta
#define RED "\033[31m"            // CÃ³digo para texto na cor vermelho
#define BLUE "\033[34m"           // CÃ³digo para texto na cor azul
#define LIGHT_BLUE  "\033[94m"    // CÃ³digo para texto na cor azul claro
#define LIGHT_YELLOW  "\033[93m"  // CÃ³digo para texto na cor amarelo claro
#define LIGHT_CYAN   "\033[96m"   // CÃ³digo para texto na cor ciano claro
#define LIGHT_GREEN   "\033[92m"  // CÃ³digo para texto na cor verde claro     
#define PURPLE "\x1B[35m"         // CÃ³digo para texto na cor roxo
#define ORANGE "\033[38;5;208m"   // CÃ³digo para texto na cor laranja
#define DOURADO "\033[1;33m"      // CÃ³digo para texto na cor dourado
#define BLACK "\033[0;30m"        // CÃ³digo para texto na cor preto

// Estrutura principal que representa um Emoji
struct emoji {                
  struct emoji *prox;  // Ponteiro para o prÃ³ximo Emoji na lista 
  struct emoji *ant;   // Ponteiro para o emoji anterior na lista
  char simbolo[16];    // Representa o sÃ­mbolo ou nome do emoji (mÃ¡ximo de 15 caracteres + null terminator)
  int popularidade;    // Popularidade do emoji (ou qualquer outra mÃ©trica usada para ordenaÃ§Ã£o)
};

// Define o tipo `Emoji` como uma forma simplificada de usar a struct `emoji`
typedef struct emoji Emoji; 

// Estrutura para representar a lista duplamente encadeada de Emojis
struct listaDuplamenteEncadeada {
  Emoji* cabeca;       // Ponteiro para o primeiro emoji da lista
  Emoji* cauda;        // Ponteiro para o Ãºltimo emoji da lista
};

// Define o tipo `ListaDuplamenteEncadeada` como uma forma simplificada de usar a struct `listaDuplamenteEncadeada`
typedef struct listaDuplamenteEncadeada ListaDuplamenteEncadeada; 

// FunÃ§Ã£o para limpar a tela e solicitar ao usuÃ¡rio pressionar ENTER para continuar
void limpar(); 
// Esta funÃ§Ã£o exibe uma mensagem solicitando ao usuÃ¡rio pressionar ENTER para continuar,
// e apÃ³s a entrada, limpa a tela com o comando apropriado para o sistema operacional.

// FunÃ§Ã£o para limpar o buffer de entrada, removendo caracteres extras
void limparbuffer(); 
// Esta funÃ§Ã£o esvazia o buffer de entrada para evitar problemas ao processar entradas de mÃºltiplos caracteres.

// FunÃ§Ã£o para remover Emoji(s) da lista com a popularidade especificada
Emoji* Remove_elem(Emoji* Ptl, int popularidade);
// Esta funÃ§Ã£o percorre a lista de emojis e remove todos os emojis que possuem a popularidade igual Ã  especificada.
// A funÃ§Ã£o retorna o ponteiro para a cabeÃ§a da lista apÃ³s as remoÃ§Ãµes.

// FunÃ§Ã£o para liberar a memÃ³ria alocada para a lista de Emojis
Emoji *Libera_lista(Emoji *Ptl);
// Esta funÃ§Ã£o percorre a lista e libera a memÃ³ria alocada para cada nÃ³, prevenindo vazamentos de memÃ³ria.
// Define a cauda como NULL apÃ³s a liberaÃ§Ã£o.

// FunÃ§Ã£o para exibir uma mensagem de boas-vindas
void boasVindas();
// Exibe uma mensagem estilizada de boas-vindas ao usuÃ¡rio, utilizando cores e emojis para uma apresentaÃ§Ã£o atraente.

// FunÃ§Ã£o para trocar os dados de dois nÃ³s
void trocar(Emoji* a, Emoji* b);
// Esta funÃ§Ã£o troca os dados (popularidade e sÃ­mbolo) entre dois emojis fornecidos como parÃ¢metros.

// FunÃ§Ã£o de ordenaÃ§Ã£o Stooge Sort para listas duplamente encadeadas
void stoogeSort(ListaDuplamenteEncadeada* Ptl, Emoji *l, Emoji *h);
// Implementa o algoritmo Stooge Sort para ordenar uma lista duplamente encadeada de emojis.
// A ordenaÃ§Ã£o Ã© feita recursivamente em trÃªs partes da lista: inÃ­cio atÃ© um terÃ§o, primeiro terÃ§o atÃ© final, e inÃ­cio atÃ© dois terÃ§os.

// FunÃ§Ã£o para ordenar a lista usando Stooge Sort e exibir o resultado
void ordenarLista(ListaDuplamenteEncadeada* Ptl);
// Chama a funÃ§Ã£o `stoogeSort` para ordenar a lista de emojis e, em seguida, exibe a lista ordenada.
// Inclui mensagens antes e depois da ordenaÃ§Ã£o e limpa a tela para melhor visualizaÃ§Ã£o.




//funcoes.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "funcoes.h"

// FunÃ§Ã£o para limpar a tela e aguardar a pressÃ£o de ENTER
void limpar() {
    // Solicita ao usuÃ¡rio para pressionar ENTER e limpar a tela
    printf("\n\n%sğŸ›‘ %sPressione ENTER para continuar... %sğŸ›‘%s: ", LIGHT_CYAN, LIGHT_YELLOW, LIGHT_CYAN, RESET);
    getchar();  // Espera a entrada do usuÃ¡rio
    #ifdef _WIN32
        system("cls");  // Comando especÃ­fico para Windows para limpar a tela
    #else
        system("clear");  // Comando especÃ­fico para Linux/Mac para limpar a tela
    #endif
}

// FunÃ§Ã£o para limpar o buffer de entrada
void limparbuffer() {
    int c;
    // Remove todos os caracteres do buffer de entrada atÃ© o fim da linha ou o EOF
    while ((c = getchar()) != '\n' && c != EOF);
}

// FunÃ§Ã£o para remover emojis com uma determinada popularidade
Emoji* Remove_elem(ListaDuplamenteEncadeada* Ptl, int popularidade, int *flag) {
    Emoji* atual = Ptl->cabeca;  // Inicia da cabeÃ§a da lista
    Emoji* aux;
    *flag = 0;  // Inicializa a flag de remoÃ§Ã£o como 0 (nenhum emoji removido ainda)

    // Percorre a lista procurando emojis com a popularidade especificada
    while (atual != NULL) {
        if (atual->popularidade == popularidade) {
            printf(BLUE "ğŸ—‘ï¸ Removendo emoji(s) com popularidade %d...\n\n" RESET, popularidade);
            
            // Ajusta os ponteiros da lista duplamente encadeada para remover o emoji
            if (atual == Ptl->cabeca) {
                Ptl->cabeca = atual->prox;  // Atualiza a cabeÃ§a da lista
                if (Ptl->cabeca != NULL) {
                    Ptl->cabeca->ant = NULL;  // Atualiza o ponteiro anterior da nova cabeÃ§a
                }
            } else {
                atual->ant->prox = atual->prox;  // Atualiza o prÃ³ximo do nÃ³ anterior
                if (atual->prox != NULL) {
                    atual->prox->ant = atual->ant;  // Atualiza o anterior do nÃ³ prÃ³ximo
                }
            }
            if (atual == Ptl->cauda) {
                Ptl->cauda = atual->ant;  // Atualiza a cauda da lista
            }

            // Libera a memÃ³ria do emoji removido
            aux = atual;
            atual = atual->prox;
            free(aux);

            *flag = 1;  // Atualiza a flag indicando que um emoji foi removido
            printf(GREEN "âœ… Emoji(s) com popularidade %d removido com sucesso!\n" RESET, popularidade);
        } else {
            atual = atual->prox;  // Move para o prÃ³ximo emoji
        }
    }

    // Mensagem se nenhum emoji com a popularidade especificada foi encontrado
    if (*flag == 0) {
        printf(YELLOW "âŒ Nenhum emoji com popularidade %d encontrado para remoÃ§Ã£o.\n" RESET, popularidade);
    }

    return Ptl->cabeca;  // Retorna a nova cabeÃ§a da lista
}

// FunÃ§Ã£o para consultar um emoji pelo sÃ­mbolo
int Consulta_elem(ListaDuplamenteEncadeada* Ptl, const char* emoji) {
    Emoji* atual = Ptl->cabeca;  // Inicia da cabeÃ§a da lista

    // Percorre a lista procurando o emoji com o sÃ­mbolo especificado
    while (atual != NULL && strcmp(atual->simbolo, emoji) != 0) {
        atual = atual->prox;
    }

    // Verifica se o emoji foi encontrado
    if (atual == NULL) {
        printf("%sğŸ’”ğŸ˜¢ %sEmoji nÃ£o encontrado! %sğŸ˜­ğŸ’§ %s\n", RED, CYAN, BLUE, RESET);
        return 0;  // Retorna 0 se o emoji nÃ£o foi encontrado
    } else {
        printf("%sğŸ˜Šâ­ %sEmoji encontrado com sucesso! %sğŸ‰â­ %s\n\n", RED, GREEN, BLUE, RESET);
        // Exibe detalhes do emoji encontrado
        printf("%sğŸŒŸğŸ”¥ %sEmoji: |------[%s]------| %sğŸš€ğŸŒˆ %s\n", RED, CYAN, atual->simbolo, MAGENTA, RESET);
        printf("%sğŸ’¥ğŸ’« %sPopularidade: %d %sâš¡ğŸŒ» %s\n\n", YELLOW, BLUE, atual->popularidade, MAGENTA, RESET);
        return 1;  // Retorna 1 se o emoji foi encontrado
    }
}

// FunÃ§Ã£o para liberar toda a memÃ³ria usada pela lista
Emoji* Libera_lista(ListaDuplamenteEncadeada* Ptl) {
    Emoji* aux = Ptl->cabeca;  // Inicia da cabeÃ§a da lista

    // Percorre a lista liberando a memÃ³ria de cada emoji
    while (aux != NULL) {
        Emoji* temp = aux;
        aux = aux->prox;
        free(temp);
    }

    Ptl->cauda = NULL;  // Define a cauda como NULL apÃ³s a liberaÃ§Ã£o da memÃ³ria
    return Ptl->cabeca;  // Retorna a nova cabeÃ§a da lista (que deve ser NULL)
}

// FunÃ§Ã£o para trocar os dados de dois emojis
void trocar(Emoji* a, Emoji* b) {
    int tempPopularidade = a->popularidade;  // Armazena a popularidade de 'a' temporariamente
    char tempSimbolo[16];
    strcpy(tempSimbolo, a->simbolo);  // Armazena o sÃ­mbolo de 'a' temporariamente

    a->popularidade = b->popularidade;  // Troca a popularidade de 'a' com 'b'
    strcpy(a->simbolo, b->simbolo);  // Troca o sÃ­mbolo de 'a' com 'b'

    b->popularidade = tempPopularidade;  // Define a popularidade de 'b' para o valor original de 'a'
    strcpy(b->simbolo, tempSimbolo);  // Define o sÃ­mbolo de 'b' para o valor original de 'a'
}

// FunÃ§Ã£o de ordenaÃ§Ã£o Stooge Sort para a lista de emojis
void stoogeSort(ListaDuplamenteEncadeada* Ptl, Emoji* l, Emoji* h) {
    // Verifica se a lista Ã© pequena demais para ordenar
    // Caso base: a lista Ã© vazia, possui um Ãºnico elemento, ou l e h sÃ£o o mesmo nÃ³
    // ou l e h sÃ£o adjacentes (isto Ã©, l estÃ¡ imediatamente antes de h)
    if (l == NULL || h == NULL || l == h || l->prox == h) return;

    // Verifica se Ã© necessÃ¡rio trocar os emojis para garantir que 'l' esteja antes de 'h'
    // Se a popularidade do emoji 'l' for maior do que a de 'h', troca os dados dos emojis
    if (l->popularidade > h->popularidade) {
        trocar(l, h);  // Chama a funÃ§Ã£o 'trocar' para trocar os dados dos emojis
    }

    // Calcula o tamanho da sublista de emojis entre l e h
    int tamanho = 1;  // Inicializa o tamanho com 1 porque l Ã© um elemento
    Emoji* temp = l;
    // Percorre a sublista para contar o nÃºmero total de elementos
    while (temp != h) {
        tamanho++;
        temp = temp->prox;  // Move para o prÃ³ximo elemento na lista
    }

    // Divide a lista em trÃªs partes e aplica o Stooge Sort recursivamente
    // O algoritmo Stooge Sort divide a lista em trÃªs partes iguais e ordena as duas partes externas
    // e a parte central
    if (tamanho > 2) {  // SÃ³ divide se o tamanho da lista for maior que 2
        int umTerco = tamanho / 3;  // Calcula o tamanho de um terÃ§o da lista

        // Determina o inÃ­cio do primeiro terÃ§o da sublista
        Emoji* primeiroTerco = l;
        for (int i = 0; i < umTerco; i++) {
            if (primeiroTerco != NULL) primeiroTerco = primeiroTerco->prox;  // AvanÃ§a um terÃ§o da lista
        }

        // Determina o inÃ­cio do segundo terÃ§o da sublista, comeÃ§ando do final e indo para trÃ¡s
        Emoji* doisTerco = h;
        for (int i = 0; i < umTerco; i++) {
            if (doisTerco != NULL) doisTerco = doisTerco->ant;  // Retrocede um terÃ§o da lista
        }

        // Aplica o Stooge Sort recursivamente nas trÃªs partes da lista
        // Ordena a sublista do inÃ­cio atÃ© o final do segundo terÃ§o
        if (primeiroTerco != NULL) stoogeSort(Ptl, l, doisTerco);
        // Ordena a sublista do inÃ­cio do primeiro terÃ§o atÃ© o final
        if (primeiroTerco != NULL && doisTerco != NULL) stoogeSort(Ptl, primeiroTerco, h);
        // Ordena novamente a sublista do inÃ­cio atÃ© o final do segundo terÃ§o
        if (primeiroTerco != NULL) stoogeSort(Ptl, l, doisTerco);
    }
}


// FunÃ§Ã£o para ordenar a lista de emojis
void ordenarLista(ListaDuplamenteEncadeada* Ptl) {
    if (Ptl->cabeca && Ptl->cauda) {
        printf(CYAN "ğŸ”„ Lista Inicial:\n" RESET);
        ExibirLista(Ptl);  // Exibe a lista inicial (ainda a ser implementado)
        printf("\n");

        limpar();  // Limpa a tela

        printf(YELLOW "ğŸš€ Iniciando a ordenaÃ§Ã£o com Stooge Sort...\n\n" RESET);
        stoogeSort(Ptl, Ptl->cabeca, Ptl->cauda);  // Ordena a lista usando Stooge Sort

        printf(GREEN "âœ… Lista Ordenada:\n" RESET);
        ExibirLista(Ptl);  // Exibe a lista ordenada (ainda a ser implementado)
        printf("\n");
    } else {
        printf(RED "âŒ A lista estÃ¡ vazia ou nÃ£o estÃ¡ corretamente inicializada.\n" RESET);
    }
}


/*
Maria isso deve ser executado no power shell para rodar emoji
cd C:\Importante\C (caminho atÃ© a pasta em que se encontra o .exe)
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8 
.\programa.exe (nome do programa.exe)
*/

// FunÃ§Ã£o para exibir mensagens de boas-vindas sobre uma lista de emojis
void boasVindas() {
    // Exibe uma borda superior da caixa de boas-vindas
    printf("\n" GREEN BOLD "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" RESET "\n");
    // Mensagem de boas-vindas com destaque para a "Lista de Emojis"
    printf(GREEN BOLD "â•‘" RESET " ğŸŒŸğŸ‰ " BOLD GREEN "Bem-vindo Ã  " RESET GREEN BOLD "Lista de Emojis do Zap" RESET GREEN BOLD " ğŸ‰ğŸŒŸ " GREEN BOLD "                              â•‘" RESET "\n");
    // Mensagem sobre explorar emojis
    printf(GREEN BOLD "â•‘" RESET " ğŸ˜€ğŸ˜ " YELLOW "Explore uma seleÃ§Ã£o divertida de emojis para usar!" RESET GREEN BOLD " ğŸ˜ğŸ˜€ " GREEN BOLD "              â•‘" RESET "\n");
    // Mensagem sobre escolher Ã­cones e expressÃµes
    printf(GREEN BOLD "â•‘" RESET " ğŸ¨ğŸ–¼ï¸ " MAGENTA "Escolha entre uma variedade de Ã­cones e expressÃµes!" RESET GREEN BOLD " ğŸ–¼ï¸ğŸ¨ " GREEN BOLD "             â•‘" RESET "\n");
    // Mensagem sobre personalizaÃ§Ã£o com emojis
    printf(GREEN BOLD "â•‘" RESET " ğŸ› ï¸âœ¨ " GREEN "Personalize suas mensagens com emojis Ãºnicos!" RESET GREEN BOLD " âœ¨ğŸ› ï¸ " GREEN BOLD "                   â•‘" RESET "\n");
    // Exibe uma borda inferior da caixa de boas-vindas
    printf(GREEN BOLD "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" RESET "\n\n");
}