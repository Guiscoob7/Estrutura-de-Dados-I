#include <stdio.h>
#include <stdlib.h>

#define TAM_MAX 1000

// ğŸ“¦ Estrutura da Pilha
typedef struct {
  int elementos[TAM_MAX];  // ğŸ“Š Array para armazenar os dados da pilha
  int indiceTopo;          // ğŸš© Indica o Ã­ndice do topo da pilha
} EstruturaPilha;

// ğŸš Estrutura da Fila
typedef struct {
  int elementos[TAM_MAX];  // ğŸ“Š Array para armazenar os dados da fila
  int indiceCauda;         // ğŸš€ Ãndice do inÃ­cio da fila
  int indiceCabeca;        // ğŸ¯ Ãndice do final da fila
} EstruturaFila;

// ğŸ† Estrutura da Fila de Prioridade
typedef struct {
  int elementos[TAM_MAX];  // ğŸ“Š Array para os dados de prioridade
  int tamanho;             // ğŸ“ Tamanho atual da fila de prioridade
} EstruturaFilaPrioridade;

// ğŸ§± Inicializa a pilha vazia
void inicializaPilha(EstruturaPilha* pilha) { 
  pilha->indiceTopo = -1;  // ğŸš« Define o topo como -1, indicando pilha vazia
}

// â• Adiciona elemento ao topo da pilha
void adicionaPilha(EstruturaPilha* pilha, int valor) { 
  pilha->elementos[++pilha->indiceTopo] = valor;  // ğŸ”¼ Incrementa o topo e insere o valor
}

// â– Remove e retorna elemento do topo da pilha
int removePilha(EstruturaPilha* pilha) { 
  return pilha->elementos[pilha->indiceTopo--];  // ğŸ”½ Retorna o valor do topo e decrementa
}

// ğŸš€ Inicializa a fila vazia
void inicializaFila(EstruturaFila* fila) { 
  fila->indiceCauda = fila->indiceCabeca = -1;  // ğŸ”„ Define Ã­ndices para indicar fila vazia
}

// â• Adiciona elemento ao final da fila
void adicionaFila(EstruturaFila* fila, int valor) {
  if (fila->indiceCabeca == -1) fila->indiceCauda = fila->indiceCabeca = 0;  // ğŸš© Primeira inserÃ§Ã£o
  else fila->indiceCabeca++;  // ğŸ¯ AvanÃ§a a cabeÃ§a
  fila->elementos[fila->indiceCabeca] = valor;  // ğŸ’¾ Armazena o valor na posiÃ§Ã£o da cabeÃ§a
}

// â– Remove e retorna elemento do inÃ­cio da fila
int removeFila(EstruturaFila* fila) {
  int valor = fila->elementos[fila->indiceCauda];  // ğŸš€ Guarda o valor da cauda
  if (fila->indiceCauda == fila->indiceCabeca) fila->indiceCauda = fila->indiceCabeca = -1;  // ğŸ”„ Fila vazia apÃ³s remoÃ§Ã£o
  else fila->indiceCauda++;  // ğŸ“ AvanÃ§a a cauda
  return valor;  // ğŸ”™ Retorna o valor removido
}

// ğŸ† Inicializa a fila de prioridade vazia
void inicializaFilaPrioridade(EstruturaFilaPrioridade* filaPrioridade) { 
  filaPrioridade->tamanho = 0;  // âš™ï¸ Define tamanho inicial como 0
}

// â• Adiciona elemento mantendo a prioridade
void adicionaFilaPrioridade(EstruturaFilaPrioridade* filaPrioridade, int valor) {
  int indiceAtual = filaPrioridade->tamanho++;  // ğŸ“ Expande o tamanho e inicia Ã­ndice
  while (indiceAtual > 0 && filaPrioridade->elementos[(indiceAtual - 1) / 2] < valor) {  // ğŸ”„ Move para cima se necessÃ¡rio
    filaPrioridade->elementos[indiceAtual] = filaPrioridade->elementos[(indiceAtual - 1) / 2];
    indiceAtual = (indiceAtual - 1) / 2;
  }
  filaPrioridade->elementos[indiceAtual] = valor;  // ğŸ“¥ Insere o valor na posiÃ§Ã£o correta
}

// ğŸ” Remove e retorna o elemento de maior prioridade
int removeFilaPrioridade(EstruturaFilaPrioridade* filaPrioridade) {
  int valorMaximo = filaPrioridade->elementos[0];  // ğŸ† Pega o valor mÃ¡ximo no topo
  filaPrioridade->elementos[0] = filaPrioridade->elementos[--filaPrioridade->tamanho];  // ğŸ”½ Substitui topo pelo Ãºltimo e reduz tamanho
  int indicePai = 0, indiceFilho;
  while (2 * indicePai + 1 < filaPrioridade->tamanho) {  // ğŸ”„ Ajusta a estrutura de heap
    indiceFilho = 2 * indicePai + 1;
    if (indiceFilho + 1 < filaPrioridade->tamanho && filaPrioridade->elementos[indiceFilho + 1] > filaPrioridade->elementos[indiceFilho]) indiceFilho++;
    if (filaPrioridade->elementos[indicePai] >= filaPrioridade->elementos[indiceFilho]) break;
    int temp = filaPrioridade->elementos[indicePai];
    filaPrioridade->elementos[indicePai] = filaPrioridade->elementos[indiceFilho];
    filaPrioridade->elementos[indiceFilho] = temp;
    indicePai = indiceFilho;
  }
  return valorMaximo;  // ğŸ”™ Retorna o valor mÃ¡ximo removido
}

// ğŸ–¥ï¸ FunÃ§Ã£o de saÃ­da para verificar tipo de estrutura de dados
void verificaEstrutura(int numOperacoes, int opList[][2]) {
  EstruturaPilha pilha;  // ğŸ“¦ Pilha auxiliar
  EstruturaFila fila;  // ğŸš Fila auxiliar
  EstruturaFilaPrioridade filaPrioridade;  // ğŸ† Fila de prioridade auxiliar
  int ePilha = 1, eFila = 1, eFilaPrioridade = 1;  // âš–ï¸ Flags de verificaÃ§Ã£o

  inicializaPilha(&pilha);  // ğŸ§± Inicializa pilha
  inicializaFila(&fila);  // ğŸš€ Inicializa fila
  inicializaFilaPrioridade(&filaPrioridade);  // ğŸ† Inicializa fila de prioridade

  // ğŸ”„ Processa as operaÃ§Ãµes para verificar estrutura
  for (int operacaoIndice = 0; operacaoIndice < numOperacoes; operacaoIndice++) {  // Alterado de operacaoIndex para operacaoIndice
    if (opList[operacaoIndice][0] == 1) {  // â• OperaÃ§Ã£o de inserÃ§Ã£o
      adicionaPilha(&pilha, opList[operacaoIndice][1]);  // ğŸ—ƒï¸ Adiciona Ã  pilha
      adicionaFila(&fila, opList[operacaoIndice][1]);  // ğŸšš Adiciona Ã  fila
      adicionaFilaPrioridade(&filaPrioridade, opList[operacaoIndice][1]);  // ğŸ… Adiciona Ã  fila de prioridade
    } else {  // â– OperaÃ§Ã£o de remoÃ§Ã£o
      if (ePilha && (pilha.indiceTopo == -1 || removePilha(&pilha) != opList[operacaoIndice][1])) ePilha = 0;
      if (eFila && (fila.indiceCauda == -1 || removeFila(&fila) != opList[operacaoIndice][1])) eFila = 0;
      if (eFilaPrioridade && (filaPrioridade.tamanho == 0 || removeFilaPrioridade(&filaPrioridade) != opList[operacaoIndice][1])) eFilaPrioridade = 0;
    }
  }

  // ğŸ–¨ï¸ Determina qual estrutura corresponde Ã s operaÃ§Ãµes
  if (ePilha && !eFila && !eFilaPrioridade) printf("stack\n");
  else if (!ePilha && eFila && !eFilaPrioridade) printf("queue\n");
  else if (!ePilha && !eFila && eFilaPrioridade) printf("priority queue\n");
  else if (!ePilha && !eFila && !eFilaPrioridade) printf("impossible\n");
  else printf("not sure\n");
}

// ğŸ FunÃ§Ã£o principal
int main() {
  int numOperacoes;
  int opList[TAM_MAX][2];

  // ğŸ”„ LÃª o nÃºmero de operaÃ§Ãµes e dados atÃ© o final da entrada
  while (scanf("%d", &numOperacoes) != EOF) {
    for (int i = 0; i < numOperacoes; i++) scanf("%d %d", &opList[i][0], &opList[i][1]);
    verificaEstrutura(numOperacoes, opList);  // âš™ï¸ Chama funÃ§Ã£o de saÃ­da para anÃ¡lise
  }

  return 0;  // ğŸ† Fim do programa
}
