//funcoes.c

#include <stdio.h>          // Inclui a biblioteca padrÃ£o de entrada e saÃ­da ğŸ“š
#include <stdlib.h>         // Inclui a biblioteca padrÃ£o de utilidades, como alocaÃ§Ã£o de memÃ³ria ğŸ§°
#include <time.h>           // Inclui a biblioteca para manipulaÃ§Ã£o de tempo â°
#include "funcoes.h"        // Inclui o cabeÃ§alho com funÃ§Ãµes e definiÃ§Ãµes personalizadas ğŸ“œ

// FunÃ§Ã£o para limpar a tela e aguardar a pressÃ£o de ENTER ğŸš¿â³
void limpar() 
{
    // ğŸ›‘ Solicita ao usuÃ¡rio para pressionar ENTER e limpar a tela
    printf("\n\n%sğŸ›‘ %sPressione ENTER para continuar... %sğŸ›‘%s: ", LIGHT_CYAN, LIGHT_YELLOW, LIGHT_CYAN, RESET);
    getchar();  // â³ Espera a entrada do usuÃ¡rio
    #ifdef _WIN32
        system("cls");  // ğŸ–¥ï¸ Comando especÃ­fico para Windows para limpar a tela
    #else
        system("clear");  // ğŸ Comando especÃ­fico para Linux/Mac para limpar a tela
    #endif
}

void limparImediato()
{
    #ifdef _WIN32
        system("cls");  // ğŸ–¥ï¸ Comando especÃ­fico para Windows para limpar a tela
    #else
        system("clear");  // ğŸ Comando especÃ­fico para Linux/Mac para limpar a tela
    #endif
}

// FunÃ§Ã£o para limpar o buffer de entrada ğŸ§¹
void limparbuffer() 
{
    int c;
    // ğŸ§¹ Remove todos os caracteres do buffer de entrada atÃ© o fim da linha ou o EOF
    while ((c = getchar()) != '\n' && c != EOF);
}

/*
ğŸ’» InstruÃ§Ãµes de execuÃ§Ã£o:
cd C:\Importante\C (caminho atÃ© a pasta em que se encontra o .exe)
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8 
.\programa.exe (nome do programa.exe)
*/

// FunÃ§Ã£o para exibir mensagens de boas-vindas sobre uma fila da morte âš°ï¸ğŸ’€
void boasVindas() 
{
    // Exibe uma borda superior da caixa de boas-vindas ğŸŒ³ğŸŒ±
    printf("\n" GREEN BOLD "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" RESET "\n");
    // ğŸŒ³ğŸŒŸ Mensagem de boas-vindas com destaque para a "Ãrvore dos Sonhos"
    printf(GREEN BOLD "â•‘" RESET " ğŸŒ³ğŸŒŸ " BOLD GREEN "Bem-vindo Ã  " RESET GREEN BOLD "Ãrvore dos Sonhos" RESET GREEN BOLD " ğŸŒŸğŸŒ³ " GREEN BOLD "                                   â•‘" RESET "\n");
    // ğŸŒ¿â³ Mensagem sobre a espera pela realizaÃ§Ã£o dos sonhos
    printf(GREEN BOLD "â•‘" RESET " ğŸŒ¿â³ " YELLOW "A realizaÃ§Ã£o dos sonhos leva tempo, aguarde sua vez na Ã¡rvore!" RESET GREEN BOLD " â³ğŸŒ¿ " GREEN BOLD "  â•‘" RESET "\n");
    // ğŸ‚ğŸŒˆ Mensagem sobre as oportunidades na vida
    printf(GREEN BOLD "â•‘" RESET " ğŸ‚ğŸŒˆ " MAGENTA "Cada sonho Ã© uma folha, escolha sabiamente seu caminho!" RESET GREEN BOLD " ğŸŒˆğŸ‚ " GREEN BOLD "         â•‘" RESET "\n");
    // ğŸŒ¸âœ¨ Mensagem sobre o crescimento e florescimento dos sonhos
    printf(GREEN BOLD "â•‘" RESET " ğŸŒ¸âœ¨ " CYAN "Os sonhos crescem com cuidado e esperanÃ§a!" RESET GREEN BOLD " âœ¨ğŸŒ¸ " GREEN BOLD "                      â•‘" RESET "\n");
    // Exibe uma borda inferior da caixa de boas-vindas ğŸŒ³ğŸŒ±
    printf(GREEN BOLD "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" RESET "\n\n");
    limpar();
}

// FunÃ§Ã£o para exibir o menu principal com opÃ§Ãµes âš°ï¸ğŸ”ª
void exibeMenu() {
    // ğŸŒ³ Exibe um menu temÃ¡tico de Ã¡rvores binÃ¡rias com emojis
    printf(GREEN "\nğŸŒ³ğŸŒ± Bem-vindo ao Gerenciador da Ãrvore dos Sonhos ğŸŒ±ğŸŒ³\n\n" RESET);
    printf(YELLOW "ğŸ“œ Escolha uma aÃ§Ã£o:\n" RESET);
    printf(GREEN "ğŸŒ¿ [1] - Plantar Nota (Inserir NÃ³)\n" RESET);
    printf(CYAN "ğŸ‚ [2] - Exibir Notas (Exibir Ãrvore)\n" RESET);
    printf(ORANGE "ğŸ” [3] - Consultar Nota (Buscar NÃ³)\n" RESET);
    printf(RED "ğŸ [4] - Remover Nota (Remover NÃ³)\n" RESET);
    printf(MAGENTA "ğŸŒ¼ [5] - Contar Notas (Contar NÃ³s)\n" RESET);
    printf(BLUE "ğŸŒ³ [6] - Contar Folhas e Galhos (NÃ³s Folhas e NÃ£o-Folhas)\n" RESET);
    printf(YELLOW "ğŸŒˆ [7] - Calcular Altura da Ãrvore\n" RESET);
    printf(ORANGE "ğŸ† [8] - Calcular Maior NÃºmero da Ãrvore\n" RESET);  
    printf(PURPLE "ğŸŒŸ [9] - Espelhar Ãrvore\n" RESET);  
    printf(PINK "ğŸŒ¸ [10] - Encerrar e Podar Ãrvore (Liberar MemÃ³ria)\n" RESET);
    printf(YELLOW "\nğŸ‘‰ FaÃ§a sua escolha: " RESET);
}

// FunÃ§Ã£o para inserir um info na Ã¡rvore binÃ¡ria ğŸŒ²
Arvore* inserirNo(Arvore* raiz, int valor) {      
    Arvore* novoNo = (Arvore*)malloc(sizeof(Arvore));  // Aloca memÃ³ria para o nÃ³ ğŸ§ 
    novoNo->valor = valor;                             // Atribui o valor ao novo nÃ³ ğŸ·ï¸
    novoNo->esquerdo = NULL;                           // Inicializa o filho esquerdo como NULL ğŸš«
    novoNo->direito = NULL;                            // Inicializa o filho direito como NULL ğŸš«

    if (raiz == NULL) {  // ğŸŒ± Verifica se a Ã¡rvore estÃ¡ vazia
        raiz = novoNo;  // A nova raiz Ã© o novo nÃ³ ğŸŒ³
        printf(PINK "\nğŸŒ± Inseri na raiz! info: %d\n" RESET, valor);  // ğŸŒ¿ Mensagem de inserÃ§Ã£o na raiz
        return raiz;  // ğŸŒ³ Retorna a nova raiz
    }

    Arvore* aux = raiz;  // ğŸ” VariÃ¡vel auxiliar para percorrer a Ã¡rvore

    while (aux != NULL) {  // ğŸ”„ Enquanto nÃ£o chegar ao final da Ã¡rvore
        if (valor < aux->valor) {  // ğŸŒ¿ Insere na subÃ¡rvore esquerda se o valor for menor
            if (aux->esquerdo == NULL) {  // ğŸŒ± Se nÃ£o houver filho Ã  esquerda
                aux->esquerdo = novoNo;  // ğŸŒ± Cria um novo nÃ³ Ã  esquerda
                printf(LIGHT_GREEN "\nğŸŒ± Inseri na esquerda! info: %d\n" RESET, valor);  // ğŸŒ¿ Mensagem de inserÃ§Ã£o na esquerda
                return raiz;  // ğŸ”™ Retorna a Ã¡rvore apÃ³s inserÃ§Ã£o
            }
            aux = aux->esquerdo;  // ğŸ‘ˆ AvanÃ§a para o nÃ³ Ã  esquerda
        } else {  // ğŸ‘‰ Insere na subÃ¡rvore direita se o valor for maior ou igual
            if (aux->direito == NULL) {  // ğŸŒ± Se nÃ£o houver filho Ã  direita
                aux->direito = novoNo;  // ğŸŒ± Cria um novo nÃ³ Ã  direita
                printf(LIGHT_BLUE "\nğŸŒ³ Inseri na direita! info: %d\n" RESET, valor);  // ğŸŒ³ Mensagem de inserÃ§Ã£o na direita
                return raiz;  // ğŸ”™ Retorna a Ã¡rvore apÃ³s inserÃ§Ã£o
            }
            aux = aux->direito;  // ğŸ‘‰ AvanÃ§a para o nÃ³ Ã  direita
        }
    }
    return raiz;  // ğŸ”™ Retorna a Ã¡rvore completa apÃ³s a inserÃ§Ã£o
}

// FunÃ§Ã£o para exibir a Ã¡rvore de forma vertical ğŸŒ³
void exibirArvore(Arvore* raiz, int espacos) {
    if (raiz == NULL) {  // ğŸŒ¸ Verifica se a Ã¡rvore estÃ¡ vazia
        printf(PINK "\nğŸŒ¸ A Ã¡rvore estÃ¡ vazia! ğŸŒ¸\n" RESET);  // ğŸŒ¼ Mensagem informativa
        return;  // ğŸšª Termina a execuÃ§Ã£o
    }

    espacos += 10;  // ğŸ”¼ Aumenta o espaÃ§o para melhor visualizaÃ§Ã£o

    if (raiz->direito != NULL)  // ğŸ” Se houver filho Ã  direita
        exibirArvore(raiz->direito, espacos);  // ğŸŒ³ Primeiro, imprime a subÃ¡rvore direita

    printf("\n");  // ğŸ“ Nova linha para separar os nÃ­veis
    for (int i = 10; i < espacos; i++) {
        printf(" "); // ğŸŒ«ï¸ Imprime espaÃ§os em branco
    }
    
    printf(LIME "ğŸŒ² %d ğŸŒ²\n" RESET, raiz->valor); // ğŸŒ³ Imprime o valor do nÃ³ com cor ğŸŒ³

    if (raiz->esquerdo != NULL)  // ğŸ” Se houver filho Ã  esquerda
        exibirArvore(raiz->esquerdo, espacos);  // ğŸŒ³ Depois, imprime a subÃ¡rvore esquerda
}

// FunÃ§Ã£o para remover um nÃ³ da Ã¡rvore ğŸ”ª
Arvore* removerNo(Arvore* raiz, int valor) {
    Arvore* atual = raiz;    // ğŸ” Ponteiro para percorrer a Ã¡rvore
    Arvore* pai = NULL;      // ğŸ‘¨â€ğŸ‘¦ Armazena o pai do nÃ³ atual

    // Encontrar o nÃ³ a ser removido e seu pai ğŸ”
    while (atual != NULL && atual->valor != valor) {  // ğŸ”„ Enquanto nÃ£o encontrar o nÃ³
        pai = atual;  // ğŸ‘¨â€ğŸ‘¦ Armazena o pai do nÃ³ atual
        if (valor < atual->valor)  // ğŸŒ¿ Se o valor for menor, vai para a subÃ¡rvore esquerda
            atual = atual->esquerdo;  // ğŸŒ² Move-se para a esquerda
        else  // ğŸ‘‰ Se o valor for maior, vai para a subÃ¡rvore direita
            atual = atual->direito;   // ğŸŒ³ Move-se para a direita
    }

    // Caso o nÃ³ nÃ£o seja encontrado âŒ
    if (atual == NULL) {
        printf(RED "\nğŸš« Valor %d nÃ£o encontrado na Ã¡rvore.\n" RESET, valor);  // ğŸŒ¼ Mensagem de valor nÃ£o encontrado
        return raiz;  // ğŸ”™ Retorna a Ã¡rvore original
    }

    // Caso 1: O nÃ³ a ser removido nÃ£o tem filhos (Ã© uma folha) ğŸŒ¿
    if (atual->esquerdo == NULL && atual->direito == NULL) {  // ğŸŒ³ Verifica se Ã© folha
        if (pai == NULL)  // ğŸŒ± O nÃ³ a ser removido Ã© a raiz
            return NULL;  // Retorna NULL se a Ã¡rvore ficar vazia
        if (pai->esquerdo == atual)  // ğŸŒ¿ Se o nÃ³ a ser removido Ã© o filho esquerdo
            pai->esquerdo = NULL;  // Desconecta o filho esquerdo
        else  // ğŸŒ³ Se o nÃ³ a ser removido Ã© o filho direito
            pai->direito = NULL;  // Desconecta o filho direito
        free(atual);  // ğŸ—‘ï¸ Libera o nÃ³
    }
    // Caso 2: O nÃ³ a ser removido tem um Ãºnico filho (esquerda ou direita) ğŸŒ±
    else if (atual->esquerdo == NULL || atual->direito == NULL) {  // ğŸŒ¿ Verifica se tem um Ãºnico filho
        Arvore* filho = (atual->esquerdo != NULL) ? atual->esquerdo : atual->direito;  // ğŸŒ³ Define o filho

        if (pai == NULL)  // ğŸŒ± Se o nÃ³ a ser removido Ã© a raiz
            raiz = filho;  // Atualiza a raiz
        else if (pai->esquerdo == atual)  // ğŸŒ¿ Se o nÃ³ a ser removido Ã© o filho esquerdo
            pai->esquerdo = filho;  // Atualiza o ponteiro do pai
        else  // ğŸŒ³ Se o nÃ³ a ser removido Ã© o filho direito
            pai->direito = filho;  // Atualiza o ponteiro do pai

        free(atual);  // ğŸ—‘ï¸ Libera o nÃ³ atual
    }
    // Caso 3: O nÃ³ a ser removido tem dois filhos ğŸŒ³
    else {
        // Encontrar o sucessor (menor valor da subÃ¡rvore direita) ğŸŒ¿
        Arvore* sucessor = atual->direito;  // ğŸŒ³ Inicia com o filho direito
        Arvore* paiSucessor = atual;  // ğŸ‘¨â€ğŸ‘¦ Armazena o pai do sucessor

        while (sucessor->esquerdo != NULL) {  // ğŸ”„ Enquanto houver filho Ã  esquerda
            paiSucessor = sucessor;  // ğŸ‘¨â€ğŸ‘¦ Atualiza o pai do sucessor
            sucessor = sucessor->esquerdo;  // ğŸŒ¿ Vai atÃ© o menor valor Ã  esquerda
        }

        // Substituir o valor do nÃ³ a ser removido pelo valor do sucessor ğŸŒ±
        atual->valor = sucessor->valor;  // ğŸŒ³ Atualiza o valor do nÃ³ atual

        // Ajustar os ponteiros do sucessor ğŸ”„
        if (paiSucessor->esquerdo == sucessor)  // ğŸŒ¿ Se o sucessor Ã© o filho esquerdo
            paiSucessor->esquerdo = sucessor->direito;  // Desconecta o sucessor
        else  // ğŸŒ³ Se o sucessor Ã© o filho direito
            paiSucessor->direito = sucessor->direito;  // Desconecta o sucessor

        free(sucessor);  // ğŸ—‘ï¸ Remove o sucessor
    }
    printf(LIME "\nğŸŒ³ Nota removido da Ã¡rvore com sucesso! âœ”ï¸\n" RESET);  // âœ… ConfirmaÃ§Ã£o de remoÃ§Ã£o
    return raiz;  // ğŸ”™ Retorna a Ã¡rvore apÃ³s remoÃ§Ã£o
}

// FunÃ§Ã£o de busca iterativa ğŸ”
int buscarNo(Arvore* raiz, int valor) {
    Arvore* atual = raiz;  // ğŸ” Ponteiro para percorrer a Ã¡rvore
    
    // Percorre a Ã¡rvore enquanto nÃ£o encontra o valor ou atinge um nÃ³ nulo ğŸ”„
    while (atual != NULL) {  // ğŸ” Enquanto nÃ£o for nulo
        if (valor == atual->valor) {  // âœ”ï¸ Se o valor Ã© encontrado
            printf(GREEN "\nâœ”ï¸ Valor %d encontrado na Ã¡rvore!\n" RESET, valor);  // ğŸŒ³ Mensagem de valor encontrado
            return 1;  // ğŸŒ¼ Retorna 1 se encontrado
        } else if (valor < atual->valor) {  // ğŸŒ¿ Se o valor buscado for menor
            atual = atual->esquerdo;  // ğŸŒ² Move-se para a esquerda
        } else {  // ğŸ‘‰ Se o valor buscado for maior
            atual = atual->direito;  // ğŸŒ³ Move-se para a direita
        }
    }

    printf(RED "\nğŸš« Valor %d nÃ£o encontrado na Ã¡rvore.\n" RESET, valor);  // ğŸŒ¼ Mensagem de valor nÃ£o encontrado
    return -1;  // ğŸŒ¸ Retorna -1 se nÃ£o encontrado
}

// FunÃ§Ã£o para contar o nÃºmero total de nÃ³s na Ã¡rvore ğŸŒ³
int contagemNos(Arvore* raiz) {
    int cont = 0;  // Inicializa o contador
    if (raiz != NULL) {  // ğŸŒ± Se a raiz nÃ£o for nula
        cont += contagemNos(raiz->esquerdo);  // ğŸŒ¿ Visita a subÃ¡rvore esquerda e soma os nÃ³s
        cont++;  // ğŸŒ³ Conta o nÃ³ atual
        cont += contagemNos(raiz->direito);   // ğŸŒ³ Visita a subÃ¡rvore direita e soma os nÃ³s
    }
    return cont;  // ğŸ”™ Retorna a contagem total de nÃ³s
}

// FunÃ§Ã£o para contar folhas e nÃ³s que nÃ£o sÃ£o folhas (internos) ğŸ‚ğŸŒ³
int contagemFolhasNaoFolhas(Arvore* raiz, int *qtdFolhas) {
    int qtdNaoFolhas = 0;  // Inicializa a contagem de nÃ³s nÃ£o-folhas
    if (raiz != NULL) {  // ğŸŒ± Se a raiz nÃ£o for nula
        qtdNaoFolhas += contagemFolhasNaoFolhas(raiz->esquerdo, qtdFolhas);  // ğŸŒ¿ SubÃ¡rvore esquerda
        if (raiz->esquerdo == NULL && raiz->direito == NULL) {
            (*qtdFolhas)++;  // ğŸŒ¼ Incrementa se for uma folha
        } else {
            qtdNaoFolhas++;  // ğŸŒ³ Incrementa se for um nÃ³ interno (nÃ£o folha)
        }
        qtdNaoFolhas += contagemFolhasNaoFolhas(raiz->direito, qtdFolhas);  // ğŸŒ³ SubÃ¡rvore direita
    }
    return qtdNaoFolhas;  // ğŸ”™ Retorna a contagem de nÃ³s nÃ£o-folhas
}

// FunÃ§Ã£o para calcular a altura da Ã¡rvore ğŸŒ²
int alturaArvore(Arvore* raiz) {
    if (raiz == NULL) {  // ğŸŒ± Se a raiz for nula
        return -1;  // ğŸ”™ Retorna -1
    } else {
        int alturaEsquerda = alturaArvore(raiz->esquerdo);  // ğŸŒ¿ Calcula a altura da subÃ¡rvore esquerda
        int alturaDireita = alturaArvore(raiz->direito);    // ğŸŒ³ Calcula a altura da subÃ¡rvore direita
        return (alturaEsquerda > alturaDireita) ? alturaEsquerda + 1 : alturaDireita + 1;  // ğŸ”™ Retorna a maior altura
    }
}

// FunÃ§Ã£o para encontrar o maior valor na Ã¡rvore ğŸŒ³
int maiorArvore(Arvore* raiz) {
    if (raiz == NULL)  // ğŸŒ± Se a raiz for nula
        return -1;  // ğŸ”™ Retorna -1

    Arvore* atual = raiz;  // ğŸ” Inicia com a raiz

    while (atual->direito != NULL)  // ğŸ”„ Enquanto houver filho Ã  direita
        atual = atual->direito;  // ğŸ‘‰ Move-se para o filho direito

    return atual->valor;  // ğŸ”™ Retorna o maior valor encontrado
}

// FunÃ§Ã£o para inverter a Ã¡rvore (espelho) ğŸ”„ğŸŒ²
void espelhoArvore(Arvore* raiz) {
    if (raiz != NULL) {  // ğŸŒ± Se a raiz nÃ£o for nula
        Arvore* temp = raiz->esquerdo;  // ğŸ·ï¸ Armazena o filho esquerdo temporariamente
        raiz->esquerdo = raiz->direito;  // ğŸŒ³ Troca o filho esquerdo com o direito
        raiz->direito = temp;  // ğŸŒ² Atribui o filho esquerdo temporÃ¡rio ao direito

        espelhoArvore(raiz->esquerdo);  // ğŸŒ¿ Inverte a subÃ¡rvore esquerda
        espelhoArvore(raiz->direito);    // ğŸŒ³ Inverte a subÃ¡rvore direita
    }
}

// FunÃ§Ã£o para liberar a Ã¡rvore da memÃ³ria ğŸ—‘ï¸
Arvore* liberarArvore(Arvore* raiz) {
    Arvore* atual = raiz;  // ğŸ” Inicia com a raiz

    while (atual != NULL) {  // ğŸ”„ Enquanto nÃ£o for nulo
        // Se o nÃ³ tem um filho direito, movemos o filho para ser a nova raiz temporÃ¡ria ğŸ”„
        if (atual->direito != NULL) {
            Arvore* temp = atual->direito;  // ğŸ·ï¸ Armazena o filho direito temporariamente
            atual->direito = NULL;  // ğŸš« Desconecta o filho direito
            raiz = temp;  // ğŸ”„ Atualiza a raiz para o filho direito
        } 
        // Se o nÃ³ tem um filho esquerdo, movemos o filho esquerdo para ser a nova raiz temporÃ¡ria ğŸŒ±
        else if (atual->esquerdo != NULL) {
            Arvore* temp = atual->esquerdo;  // ğŸ·ï¸ Armazena o filho esquerdo temporariamente
            atual->esquerdo = NULL;  // ğŸš« Desconecta o filho esquerdo
            raiz = temp;  // ğŸ”„ Atualiza a raiz para o filho esquerdo
        } 
        // Se nÃ£o hÃ¡ filhos, liberamos o nÃ³ atual e avanÃ§amos ğŸ—‘ï¸
        else {
            free(atual);  // ğŸ—‘ï¸ Libera o nÃ³ atual
            raiz = NULL;  // ğŸŒ± Atualiza a raiz para NULL apÃ³s liberar todos os nÃ³s
            break;  // ğŸ”š Quando a Ã¡rvore estiver vazia, paramos
        }
        atual = raiz;  // ğŸ”„ Atualiza o ponteiro atual para a nova raiz
    }
    return raiz;  // ğŸ”™ Retorna a Ã¡rvore liberada
}

// Gera um nÃºmero aleatÃ³rio entre min e max ğŸ²ğŸ”¢
int gerarNumeroAleatorio(int min, int max) {
    return rand() % (max - min + 1) + min;  // ğŸ”„ Gera um nÃºmero aleatÃ³rio no intervalo
}