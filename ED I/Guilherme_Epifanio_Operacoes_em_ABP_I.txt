#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Estrutura do nÃ³ da Ã¡rvore binÃ¡ria ğŸŒ³
typedef struct Nozinho {
    char dado;            // Valor armazenado no nÃ³ ğŸŒŸ
    struct Nozinho* esquerda;   // Ponteiro para o filho Ã  esquerda ğŸ‘ˆ
    struct Nozinho* direita;    // Ponteiro para o filho Ã  direita ğŸ‘‰
} *ArvoreBinaria;

// FunÃ§Ã£o para criar uma Ã¡rvore vazia ğŸŒ±
ArvoreBinaria criarArvoreVazia() {
    return NULL;  // Retorna uma Ã¡rvore sem elementos ğŸŒ¿
}

// FunÃ§Ã£o para adicionar um valor Ã  Ã¡rvore binÃ¡ria de busca ğŸ”§
ArvoreBinaria adicionarValor(ArvoreBinaria raiz, const char dado) {
    // Aloca memÃ³ria para o novo nÃ³ ğŸ§©
    ArvoreBinaria novoNozinho = (ArvoreBinaria)malloc(sizeof(struct Nozinho));
    if (novoNozinho == NULL) return raiz;  // Verifica se a alocaÃ§Ã£o falhou âŒ
    novoNozinho->dado = dado;            // Atribui o valor ao novo nÃ³ ğŸŒŸ
    novoNozinho->esquerda = NULL;          // Define o filho Ã  esquerda como NULL ğŸš«
    novoNozinho->direita = NULL;           // Define o filho Ã  direita como NULL ğŸš«

    // Se a Ã¡rvore estiver vazia, define o novo nÃ³ como raiz ğŸŒ±
    if (raiz == NULL) return novoNozinho;

    // VariÃ¡veis auxiliares para encontrar o local de inserÃ§Ã£o ğŸ§­
    ArvoreBinaria atual = raiz;  // ComeÃ§a da raiz
    ArvoreBinaria pai = NULL;    // Guarda o nÃ³ pai para a inserÃ§Ã£o

    // Percorre a Ã¡rvore atÃ© encontrar uma posiÃ§Ã£o vazia âš™ï¸
    while (atual != NULL) {
        pai = atual;  // Atualiza o pai para o nÃ³ atual
        if (dado < atual->dado) {
            atual = atual->esquerda;  // Move para a esquerda ğŸ‘ˆ
        } else {
            atual = atual->direita;   // Move para a direita ğŸ‘‰
        }
    }

    // Insere o novo nÃ³ Ã  esquerda ou Ã  direita do pai ğŸ”‘
    if (dado < pai->dado) {
        pai->esquerda = novoNozinho;   // Insere Ã  esquerda ğŸ‘ˆ
    } else {
        pai->direita = novoNozinho;    // Insere Ã  direita ğŸ‘‰
    }

    return raiz;  // Retorna a raiz atualizada ğŸ¡
}

// FunÃ§Ã£o para buscar um valor na Ã¡rvore ğŸ”
ArvoreBinaria buscarValor(ArvoreBinaria raiz, const char dado) {
    ArvoreBinaria atual = raiz;  // ComeÃ§a da raiz
    while (atual != NULL) {
        if (dado == atual->dado) {
            return atual;  // Retorna o nÃ³ encontrado ğŸ¯
        } else if (dado < atual->dado) {
            atual = atual->esquerda;  // Move para a esquerda ğŸ‘ˆ
        } else {
            atual = atual->direita;   // Move para a direita ğŸ‘‰
        }
    }
    return NULL;  // Retorna NULL se o valor nÃ£o for encontrado âŒ
}

// Percurso infixo (esquerda, raiz, direita) ğŸ”„
void percorrerEmOrdemInfixa(ArvoreBinaria raiz, int *espaco) {
    if (raiz != NULL) {
        percorrerEmOrdemInfixa(raiz->esquerda, espaco);  // Percorre Ã  esquerda ğŸ‘ˆ
        if (!(*espaco)) 
            printf(" ");  // EspaÃ§o entre valores
        printf("%c", raiz->dado);  // Imprime o valor do nÃ³ ğŸŒŸ
        *espaco = 0;  // Remove o espaÃ§o para a prÃ³xima impressÃ£o
        percorrerEmOrdemInfixa(raiz->direita, espaco);  // Percorre Ã  direita ğŸ‘‰
    }
}

// Percurso prefixo (raiz, esquerda, direita) ğŸ“œ
void percorrerEmOrdemPrefixa(ArvoreBinaria raiz, int *espaco) {
    if (raiz != NULL) {
        if (!(*espaco)) 
            printf(" ");
        printf("%c", raiz->dado);  // Imprime o valor do nÃ³ ğŸŒŸ
        *espaco = 0;
        percorrerEmOrdemPrefixa(raiz->esquerda, espaco);  // Percorre Ã  esquerda ğŸ‘ˆ
        percorrerEmOrdemPrefixa(raiz->direita, espaco);   // Percorre Ã  direita ğŸ‘‰
    }
}

// Percurso posfixo (esquerda, direita, raiz) ğŸ”š
void percorrerEmOrdemPosfixa(ArvoreBinaria raiz, int *espaco) {
    if (raiz != NULL) {
        percorrerEmOrdemPosfixa(raiz->esquerda, espaco);  // Percorre Ã  esquerda ğŸ‘ˆ
        percorrerEmOrdemPosfixa(raiz->direita, espaco);   // Percorre Ã  direita ğŸ‘‰
        
        if (!(*espaco)) 
            printf(" ");
        printf("%c", raiz->dado);  // Imprime o valor do nÃ³ ğŸŒŸ
        *espaco = 0;
    }
}

// FunÃ§Ã£o para processar comandos e interagir com o usuÃ¡rio ğŸ®
void processarOperacoes(ArvoreBinaria *raiz) {
    char cmd[10];   // Comando recebido do usuÃ¡rio
    char dado;     // Valor associado ao comando

    // LÃª os comandos enquanto houver entrada ğŸ“¥
    while (scanf("%s", cmd) != EOF) {
        if (cmd[0] == 'I' && cmd[1] == '\0') {
            scanf(" %c", &dado);   // LÃª o valor para inserÃ§Ã£o
            *raiz = adicionarValor(*raiz, dado);  // Adiciona o valor ğŸŒ±
        } else if (cmd[0] == 'P' && cmd[1] == '\0') {
            scanf(" %c", &dado);  // LÃª o valor para busca
            // Busca o valor e imprime o resultado ğŸ”
            if (buscarValor(*raiz, dado)) 
                printf("%c existe\n", dado);  // Valor encontrado âœ”ï¸
            else 
                printf("%c nao existe\n", dado);  // Valor nÃ£o encontrado âŒ
        } else if (strcmp(cmd, "INFIXA") == 0) {
            int espaco = 1;
            percorrerEmOrdemInfixa(*raiz, &espaco);  // Percorre em ordem infixa ğŸŒŸ
            printf("\n");  // Quebra de linha apÃ³s o percurso
        } else if (strcmp(cmd, "PREFIXA") == 0) {
            int espaco = 1;
            percorrerEmOrdemPrefixa(*raiz, &espaco);  // Percorre em ordem prefixa ğŸŒŸ
            printf("\n");  // Quebra de linha apÃ³s o percurso
        } else if (strcmp(cmd, "POSFIXA") == 0) {
            int espaco = 1;
            percorrerEmOrdemPosfixa(*raiz, &espaco);  // Percorre em ordem posfixa ğŸŒŸ
            printf("\n");  // Quebra de linha apÃ³s o percurso
        }
    }
}

// FunÃ§Ã£o principal ğŸš€
int main() {
    ArvoreBinaria raiz = criarArvoreVazia();  // Inicializa a Ã¡rvore vazia ğŸŒ±

    processarOperacoes(&raiz);  // Inicia a interaÃ§Ã£o com o usuÃ¡rio ğŸ®

    return 0;  // Finaliza o programa com sucesso ğŸ
}
