#include "funcoes.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// FunÃ§Ã£o para limpar a tela e solicitar ao usuÃ¡rio pressionar ENTER para continuar
void limpar() {
    // Mensagem para o usuÃ¡rio pressionar ENTER
    printf("\n\n%sğŸ›‘ %sPressione ENTER para continuar... %sğŸ›‘%s: ", LIGHT_CYAN, LIGHT_YELLOW, LIGHT_CYAN, RESET);

    // Pausa atÃ© o usuÃ¡rio pressionar ENTER
    getchar();

    #ifdef _WIN32
        system("cls");  // Comando para limpar a tela no Windows
    #else
        system("clear");  // Comando para limpar a tela em Unix/Linux
    #endif
}

// FunÃ§Ã£o para limpar o buffer de entrada, removendo caracteres extras
void limparbuffer() {
    int c;
    // LÃª atÃ© o fim da linha ou fim do arquivo (EOF) para limpar o buffer
    while ((c = getchar()) != '\n' && c != EOF);
}

// FunÃ§Ã£o para liberar a memÃ³ria da lista circular
Pessoa* Libera_lista(Pessoa* Ptl) {
    Pessoa *pt, *aux;
    
    // Se a lista estiver vazia, nÃ£o hÃ¡ nada a liberar
    if (Ptl == NULL)
        return NULL;  

    // Libera todos os elementos da lista
    pt = Ptl->prox;
    while (pt != Ptl) {
        aux = pt;
        pt = pt->prox;
        free(aux);  // Libera cada elemento
    }
    free(Ptl);  // Libera o Ãºltimo elemento (cabeÃ§a)
    
    return NULL;  // Retorna NULL, indicando que a lista foi liberada
}

// FunÃ§Ã£o para criar uma lista vazia (retorna NULL)
Pessoa *Cria_lista(void) {
    return NULL;
}

// FunÃ§Ã£o para verificar se a lista estÃ¡ vazia
int E_vazia(Pessoa *Ptl) {
    // Se a lista Ã© NULL, ela estÃ¡ vazia
    return (Ptl == NULL);
}

// FunÃ§Ã£o para inserir um elemento na lista circular
Pessoa* Insere_elem(Pessoa* Ptl, char *nome) {
    Pessoa *Ptno;

    // Aloca memÃ³ria para o novo elemento da lista
    Ptno = (Pessoa*)malloc(sizeof(Pessoa));
    if (Ptno == NULL) {
        return Ptl;  // Se nÃ£o foi possÃ­vel alocar, retorna a lista original
    }

    // Define a posiÃ§Ã£o do novo elemento
    int num = Tamanho_Lista(Ptl) + 1;
    Ptno->posicao = num;
    strcpy(Ptno->nome, nome);  // Copia o nome para o novo elemento

    // Se a lista estiver vazia, o novo elemento aponta para ele mesmo
    if (Ptl == NULL) {
        Ptl = Ptno;
        Ptno->prox = Ptno;
        Ptno->ant = Ptno;
    } else {
        // Insere o novo elemento logo apÃ³s a cabeÃ§a da lista
        Ptno->prox = Ptl->prox;
        Ptno->ant = Ptl;
        Ptl->prox->ant = Ptno;
        Ptl->prox = Ptno;
        Ptl = Ptno;  // O novo elemento se torna a nova cabeÃ§a da lista
    }

    return Ptl;
}

// FunÃ§Ã£o para remover um elemento da lista circular
Pessoa* Remove_elem(Pessoa* Ptl, int suicidio, int *posicao) {
    // Verifica se a lista estÃ¡ vazia
    if (Ptl == NULL) {
        printf("%sğŸ” A Lista jÃ¡ estÃ¡ vazia!%s\n", YELLOW, RESET);
        return Ptl;
    }

    Pessoa *ant, *atual;
    atual = Ptl->prox;
    ant = Ptl;
    int cont_pos = 1;
    if (*posicao + suicidio >= Tamanho_Lista(Ptl))
        cont_pos++;
    // Ajusta a posiÃ§Ã£o da pessoa a ser removida
    
    if (*posicao) {
        // Percorre atÃ© a posiÃ§Ã£o indicada
        while (cont_pos < *posicao) {
            ant = atual;
            atual = atual->prox;
            cont_pos++;
        }
    }
    
    cont_pos = 1;
    // Localiza o elemento a ser removido com base no nÃºmero sorteado (suicidio)
    while (cont_pos < suicidio) {
        ant = atual;
        atual = atual->prox;
        cont_pos++;
    }

    // ObtÃ©m a posiÃ§Ã£o do elemento a ser removido
    int cont = Tamanho_Lista(Ptl);
    *posicao = atual->posicao;

    // Exibe mensagem informando quem serÃ¡ removido
    printf("%sğŸ’£ğŸ”¥ A pessoa que serÃ¡ eliminada Ã© da posiÃ§Ã£o %d! ğŸ”¥ğŸ’£%s\n", RED, *posicao, RESET);
    limpar();  // Pausa para o usuÃ¡rio visualizar

    // Exibe a forma como a pessoa "se suicidou"
    printf("%s\n(%dÂºLugar)\nğŸ’€ %s %s %s %s %s Se suicidou com 50 tiros nas costas. ğŸ’€%s\n",
           PURPLE, cont, RESET, LIGHT_CYAN, atual->nome, RESET, RED, RESET);
    
    // Salva a posiÃ§Ã£o do eliminado em um arquivo
    Salvar_lista(Ptl, *posicao);

    // Caso a lista tenha apenas um elemento
    if (atual->prox == Ptl && atual->ant == atual) {
        free(atual);
        return Ptl;  // Retorna a lista vazia
    } else {
        // Remove o elemento atual
        ant->prox = atual->prox;
        atual->prox->ant = ant;
        if (atual == Ptl) {
            Ptl = ant;  // Se o Ãºltimo foi removido, ajusta a cabeÃ§a
        }
        free(atual);  // Libera a memÃ³ria do elemento removido
    }

    return Ptl;  
}

// FunÃ§Ã£o para contar o nÃºmero de elementos na lista circular
int Tamanho_Lista(Pessoa* Ptl) {
    Pessoa *pt;
    int cont = 0;

    // Se a lista estiver vazia, retorna 0
    if (Ptl == NULL)
        return 0;

    // Percorre a lista para contar os elementos
    pt = Ptl->prox;
    cont = 1;
    while (pt != Ptl) {
        pt = pt->prox;
        cont++;
    }

    return cont;  // Retorna o nÃºmero de elementos
}

// FunÃ§Ã£o para salvar a posiÃ§Ã£o de uma pessoa eliminada em um arquivo
void Salvar_lista(Pessoa *Ptl, int suicidio) {
    FILE *file;
    file = fopen("perdedores.txt", "a");  // Abre o arquivo para adicionar conteÃºdo

    // Verifica se o arquivo foi aberto corretamente
    if (file == NULL) {
        printf("%sâŒ %sErro ao abrir o arquivo!%s\n", RED, BOLD, RESET);
        limpar();
        return;
    }

    // Procura o elemento correspondente ao nÃºmero sorteado
    Pessoa *aux = Ptl->prox;
    int cont = Tamanho_Lista(Ptl);
    while (1) {
        if (aux->posicao == suicidio) {
            // Grava as informaÃ§Ãµes do perdedor no arquivo
            fprintf(file, "%dÂº Lugar. %s\n", cont, aux->nome);
            fprintf(file, "PosiÃ§Ã£o: %d\n\n", aux->posicao);
            break;
        }
        aux = aux->prox;
    }

    fclose(file);  // Fecha o arquivo
}

// FunÃ§Ã£o para salvar o ganhador da lista no arquivo
void Salvar_Ganhador(Pessoa *Ptl) {
    FILE *file;
    file = fopen("ganhador.txt", "a");  // Abre o arquivo para adicionar conteÃºdo

    // Verifica se o arquivo foi aberto corretamente
    if (file == NULL) {
        printf("%sâŒ %sErro ao abrir o arquivo!%s\n", RED, BOLD, RESET);
        limpar();
        return;
    }    

    // Grava as informaÃ§Ãµes do ganhador no arquivo
    fprintf(file, "1Âº Lugar. %s\n", Ptl->nome);
    fprintf(file, "PosiÃ§Ã£o: %d\n\n", Ptl->posicao);

    fclose(file);  // Fecha o arquivo
}

// FunÃ§Ã£o para exibir a lista de pessoas
void Exibir_lista(Pessoa* Ptl) {
    // Verifica se a lista estÃ¡ vazia
    if (Ptl == NULL) {
        printf("%sğŸš« Nenhuma pessoa na lista. ğŸš«%s\n", MAGENTA, RESET);
        return;
    }

    // Exibe a lista de participantes com formataÃ§Ã£o
    printf("%s\n\nğŸŸ¢ InÃ­cio dos SuicÃ­das ğŸŸ¢%s\n\n", GREEN, RESET);
    Pessoa *pt = Ptl->prox;
    do {
        printf("%s ğŸ‘¤ Nome: %s %s|%s ğŸ“ PosiÃ§Ã£o: %d ğŸŒŸ%s\n\n", LIGHT_BLUE, pt->nome, RESET, PURPLE, pt->posicao, RESET);
        pt = pt->prox;
    } while (pt != Ptl->prox);

    printf("%sğŸ”´ Fim da Lista ğŸ”´%s\n\n\n", RED, RESET);
}

/*
cd C:\Importante\C
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
.\programa.exe
*/

// FunÃ§Ã£o para exibir mensagens de boas-vindas
void boasVindas() {
    printf("\n" RED BOLD "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" RESET "\n");
    printf(RED BOLD "â•‘" RESET " ğŸ†ğŸ”ª " BLACK BOLD "Bem-vindo ao " RESET GREEN "Jogo de Josephus" RED " ğŸ”ªğŸ† " RED BOLD "                                   â•‘" RESET "\n");
    printf(RED BOLD "â•‘" RESET "âš”ï¸ğŸ”„ " YELLOW "A luta pela sobrevivÃªncia comeÃ§a agora!" RED " ğŸ”„âš”ï¸ " RED BOLD "                         â•‘" RESET "\n");
    printf(RED BOLD "â•‘" RESET " ğŸ¯ğŸ’€ " MAGENTA "Desafie a sorte e veja quem serÃ¡ o Ãºltimo sobrevivente!" RED " ğŸ’€ğŸ¯ " RED BOLD "         â•‘" RESET "\n");
    printf(RED BOLD "â•‘" RESET " ğŸ­ğŸ”¥ " GREEN "Prepare-se para um jogo de eliminaÃ§Ã£o implacÃ¡vel!" RED " ğŸ”¥ğŸ­ " RED BOLD "               â•‘" RESET "\n");
    printf(RED BOLD "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" RESET "\n\n");
}
