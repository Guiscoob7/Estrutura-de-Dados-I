#include <stdio.h>
#include <stdlib.h>
#include "funcoes.h"

// ğŸš€ FunÃ§Ã£o para criar uma fila nova
Fila* Cria_Fila(void)
{
  Fila *Ptf;
  Ptf = (Fila*)malloc(sizeof(Fila));  // AlocaÃ§Ã£o de memÃ³ria para uma nova fila
  if (Ptf == NULL)                    // Verifica se a alocaÃ§Ã£o foi bem-sucedida
    return NULL;
  Ptf->Prim = NULL;                   // Inicializa a cabeÃ§a e o final da fila como NULL
  Ptf->Ult = NULL;
  return Ptf;
}

// â• FunÃ§Ã£o para inserir um elemento na fila
Fila *Insere_Fila(Fila *Ptf, int elem)
{
  No *Pt;
  Pt = (No*)malloc(sizeof(No));        // Aloca memÃ³ria para um novo nÃ³
  if (Pt == NULL)
    return Ptf;
  Pt->info = elem;                     // Atribui o valor ao nÃ³
  Pt->prox = NULL;                     // Define o prÃ³ximo nÃ³ como NULL
  if (Ptf->Ult == NULL)                // Se a fila estÃ¡ vazia
    Ptf->Prim = Pt;
  else
    Ptf->Ult->prox = Pt;               // Adiciona o novo nÃ³ ao final da fila
  
  Ptf->Ult = Pt;                       // Atualiza o ponteiro do final da fila
  return Ptf;
}

// â– FunÃ§Ã£o para remover um elemento da fila
int Remove_fila(Fila *Ptf, int *elem)
{
  No* aux;
  if (Ptf == NULL || Ptf->Prim == NULL) // Verifica se a fila Ã© vÃ¡lida e nÃ£o estÃ¡ vazia
    return 0;

  *elem = Ptf->Prim->info;              // Captura o valor do primeiro elemento
  aux = Ptf->Prim;                      // Ponteiro auxiliar para liberar memÃ³ria
  Ptf->Prim = Ptf->Prim->prox;          // Atualiza a cabeÃ§a da fila
  if (Ptf->Prim == NULL)
    Ptf->Ult = NULL;                    // Se a fila ficou vazia, atualiza o final
  free(aux);                            // Libera a memÃ³ria do nÃ³ removido
  return 1;
}

// ğŸ” FunÃ§Ã£o para consultar o primeiro elemento da fila (sem remover)
int Consulta_fila(Fila *Ptf, int *elem)
{
  if (Ptf == NULL || Ptf->Prim == NULL) // Verifica se a fila Ã© vÃ¡lida e nÃ£o estÃ¡ vazia
    return 0;
  *elem = Ptf->Prim->info;              // Retorna o valor do primeiro elemento
  return 1;
}

// ğŸ—‘ï¸ FunÃ§Ã£o para liberar a memÃ³ria de toda a fila
Fila *Libera_fila(Fila *Ptf)
{
    No *aux;
    if (Ptf == NULL)
        return NULL;
    while (Ptf->Prim != NULL)
    {
        aux = Ptf->Prim;               // Libera nÃ³ por nÃ³ da fila
        Ptf->Prim = Ptf->Prim->prox;
        free(aux);
    }
    free(Ptf);                         // Libera a estrutura da fila
    return NULL;
}

// ğŸ–¨ï¸ FunÃ§Ã£o para exibir todos os elementos da fila
void Exibir_Fila(Fila* Ptf)
{
    int elem;
    printf(" | ");
    while (Ptf->Ult != NULL){          // Exibe e remove os elementos da fila
        Remove_fila(Ptf, &elem);
        printf(GREEN "%02d" RESET " | ", elem);
    }
}

// ğŸ”„ FunÃ§Ã£o para manipular as filas (distribuiÃ§Ã£o por mÃºltiplos)
void Manipular_fila(Fila* filas[])
{
  No *atual = filas[0]->Prim;
  while (atual != NULL)
  {
      int info = atual->info;

      if (info % 2 == 0)                  // Verifica se o nÃºmero Ã© mÃºltiplo de 2
      {
          filas[1] = Insere_Fila(filas[1], info);
      }
      if (info % 3 == 0)                  // Verifica se o nÃºmero Ã© mÃºltiplo de 3
      {
          filas[2] = Insere_Fila(filas[2], info);
      }
      if (info % 2 != 0 && info % 3 != 0) // Caso nÃ£o seja mÃºltiplo de 2 nem 3
      {
          filas[3] = Insere_Fila(filas[3], info); 
      }
      atual = atual->prox;                // AvanÃ§a para o prÃ³ximo nÃ³
  }
}

// ğŸ§¹ FunÃ§Ã£o para limpar a tela
void limpar() {
    // Mensagem para o usuÃ¡rio pressionar ENTER
    printf("\n%sğŸ›‘ %sPressione ENTER para continuar... %sğŸ›‘%s: ", LIGHT_CYAN, ORANGE, LIGHT_CYAN, RESET);

    // Pausa atÃ© o usuÃ¡rio pressionar ENTER
    getchar();

    #ifdef _WIN32
        system("cls");  // Comando para limpar a tela no Windows
    #else
        system("clear");  // Comando para limpar a tela em Unix/Linux
    #endif
}

// ğŸ§¼ FunÃ§Ã£o para limpar o buffer de entrada, removendo caracteres extras
void limparbuffer() {
  int c;
  while ((c = getchar()) != '\n' && c != EOF);  // Limpa todos os caracteres atÃ© o ENTER
}

// FunÃ§Ã£o para exibir mensagens de boas-vindas
void boasVindas() {
    printf("\n" BLUE BOLD "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" RESET "\n");
    printf(BLUE BOLD "â•‘" RESET " ğŸš€ğŸ“¥ " GREEN BOLD "Bem-vindo ao" RESET " " CYAN BOLD "Gerenciador de Filas" GREEN " ğŸ“¥ğŸš€ " BLUE BOLD "                               â•‘" RESET "\n");
    printf(BLUE BOLD "â•‘" RESET " ğŸƒâ€â™‚ï¸ğŸ”„ " LIGHT_GREEN "Prepare-se para manipular suas filas com eficiÃªncia!" BLUE " ğŸ”„ğŸƒâ€â™‚ï¸ " BLUE BOLD "          â•‘" RESET "\n");
    printf(BLUE BOLD "â•‘" RESET " ğŸ“Šâœ… " YELLOW "Organize, insira e remova elementos com facilidade!" BLUE " âœ…ğŸ“Š " BLUE BOLD "             â•‘" RESET "\n");
    printf(BLUE BOLD "â•‘" RESET " ğŸ’¡ğŸ—ƒï¸ " LIGHT_CYAN "Vamos otimizar seu gerenciamento de dados em filas!" BLUE " ğŸ—ƒï¸ğŸ’¡ " BLUE BOLD "             â•‘" RESET "\n");
    printf(BLUE BOLD "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" RESET "\n\n");
}
