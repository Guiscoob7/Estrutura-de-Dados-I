//funcoes.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include "funcoes.h"

#define TAM_SEQUENCIA 5

// Fun√ß√£o para limpar a tela e aguardar a press√£o de ENTER üöø‚è≥
void limpar() 
{
    // üõë Solicita ao usu√°rio para pressionar ENTER e limpar a tela
    printf("\n\n%süõë %sPressione ENTER para continuar... %süõë%s: ", LIGHT_CYAN, LIGHT_YELLOW, LIGHT_CYAN, RESET);
    getchar();  // ‚è≥ Espera a entrada do usu√°rio
    #ifdef _WIN32
        system("cls");  // üñ•Ô∏è Comando espec√≠fico para Windows para limpar a tela
    #else
        system("clear");  // üçè Comando espec√≠fico para Linux/Mac para limpar a tela
    #endif
}

void limparImediato()
{
    #ifdef _WIN32
        system("cls");  // üñ•Ô∏è Comando espec√≠fico para Windows para limpar a tela
    #else
        system("clear");  // üçè Comando espec√≠fico para Linux/Mac para limpar a tela
    #endif
}

// Fun√ß√£o para limpar o buffer de entrada üßπ
void limparbuffer() 
{
    int c;
    // üßπ Remove todos os caracteres do buffer de entrada at√© o fim da linha ou o EOF
    while ((c = getchar()) != '\n' && c != EOF);
}

/*
üíª Instru√ß√µes de execu√ß√£o:
cd C:\Importante\C (caminho at√© a pasta em que se encontra o .exe)
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8 
.\programa.exe (nome do programa.exe)
*/

// Fun√ß√£o para exibir mensagens de boas-vindas sobre uma fila da morte ‚ö∞Ô∏èüíÄ
void boasVindas() 
{
    // Exibe uma borda superior da caixa de boas-vindas ‚ö∞Ô∏èüíÄ
    printf("\n" RED BOLD "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" RESET "\n");
    // üíÄ‚öîÔ∏è Mensagem de boas-vindas com destaque para a "Fila da Morte"
    printf(RED BOLD "‚ïë" RESET " üíÄ‚öîÔ∏è " BOLD RED "Bem-vindo √† " RESET RED BOLD "Fila da Morte" RESET RED BOLD " ‚öîÔ∏èüíÄ " RED BOLD "                                       ‚ïë" RESET "\n");
    // ‚ò†Ô∏è‚è≥ Mensagem sobre o fim iminente na fila
    printf(RED BOLD "‚ïë" RESET " ‚ò†Ô∏è‚è≥ " YELLOW "A morte √© inevit√°vel, aguarde sua vez na fila!" RESET RED BOLD " ‚è≥‚ò†Ô∏è " RED BOLD "                  ‚ïë" RESET "\n");
    // ‚ö∞Ô∏èüíâ Mensagem sobre o destino cruel que aguarda
    printf(RED BOLD "‚ïë" RESET " ‚ö∞Ô∏èüíâ " MAGENTA "Seu destino est√° selado, escolha seu crime final!" RESET RED BOLD " üíâ‚ö∞Ô∏è " RED BOLD "               ‚ïë" RESET "\n");
    // üó°Ô∏èüî• Mensagem sobre o julgamento sombrio
    printf(RED BOLD "‚ïë" RESET " üó°Ô∏èüî• " GREEN "O julgamento √© implac√°vel, s√≥ resta o fim!" RESET RED BOLD " üî•üó°Ô∏è " RED BOLD "                      ‚ïë" RESET "\n");
    // Exibe uma borda inferior da caixa de boas-vindas ‚ö∞Ô∏èüíÄ
    printf(RED BOLD "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" RESET "\n\n");
    limpar();
}

// Fun√ß√£o para exibir o menu principal com op√ß√µes ‚ö∞Ô∏èüî™
void exibeMenu() 
{
    // üíÄ Exibe um menu sombrio e com emojis apropriados ao tema da morte
    printf(RED "\nüïØÔ∏è‚ö∞Ô∏è Bem-vindo ao Gerenciador da Fila da Morte ‚ö∞Ô∏èüïØÔ∏è\n\n" RESET);
    printf(YELLOW "üìú Escolha seu destino:\n" RESET);
    printf(RED "üî™ [1] - Adicionar Condenado\n" RESET);  
    printf(GREEN "‚öñÔ∏è [2] - Exibir Condenados\n" RESET);  
    printf(BLUE "ü©∏ [3] - Consultar Condenado\n" RESET);  
    printf(CYAN "‚öîÔ∏è [4] - Executar Condenado\n" RESET);  
    printf(MAGENTA "üìâ [5] - Analisar Tempo da Fila Est√°tica\n" RESET);  
    printf(DOURADO "üìä [6] - Analisar Tempo da Fila Din√¢mica\n" RESET);  
    printf(PINK "ü©∏ [7] - Desafiar Condenado\n" RESET);  // Agora op√ß√£o 7
    printf(RED "üö™ [8] - Abandonar a Fila\n" RESET);  // Agora op√ß√£o 8
    printf(YELLOW "\nüëâ Fa√ßa sua escolha: " RESET);  
}



// Fun√ß√£o para criar a fila est√°tica da "morte" ‚ö∞Ô∏èüõ†Ô∏è
filaDaMorteEstatica* criarFilaEstatica(filaDaMorteEstatica *fila) 
{
    fila = (filaDaMorteEstatica*)malloc(sizeof(filaDaMorteEstatica));
    if (fila) {
        fila->IF = 0;
        fila->FF = 0;
        fila->N = 0;
    } else {
        printf(RED "‚ö†Ô∏è Erro ao criar a fila est√°tica da morte!\n" RESET);
    }
    return fila;
}

// Fun√ß√£o para criar a fila din√¢mica da "morte" ‚ö∞Ô∏èüîÑ
filaDaMorteDinamica* criarFilaDinamica(filaDaMorteDinamica *fila) 
{
    fila = (filaDaMorteDinamica*)malloc(sizeof(filaDaMorteDinamica));
    if (fila) {
        fila->Prim = NULL;
        fila->Ult = NULL;
    } else {
        printf(RED "‚ö†Ô∏è Erro ao criar a fila din√¢mica da morte!\n" RESET);
    }
    return fila;
}

// Verifica se a fila est√°tica est√° cheia üìãüü°
int filaCheiaEstatica(filaDaMorteEstatica* fila) 
{
    return (fila->N == MAX_FILA);
}

// Verifica se a fila est√°tica est√° vazia üìã‚ö™
int filaVaziaEstatica(filaDaMorteEstatica* fila) 
{
    return (fila->N == 0);
}

// Verifica se a fila din√¢mica est√° vazia üìã‚ö™üîÑ
int filaVaziaDinamica(filaDaMorteDinamica* fila) 
{
    return (fila->Prim == NULL);
}

// Libera os n√≥s da fila din√¢mica ‚ôªÔ∏èüîÑ
filaDaMorteDinamica* liberarFilaDinamica(filaDaMorteDinamica* fila) {
    noDinamico* aux;
    while (fila->Prim != NULL) {
        aux = fila->Prim;
        fila->Prim = fila->Prim->prox;
        free(aux);
    }
    fila->Prim = NULL;
    fila->Ult = NULL;
    printf(GREEN "‚ôªÔ∏è Fila Din√¢mica liberada!\n\n" RESET);
    return fila;
}

// Insere uma pessoa na fila est√°tica üë§üìã
int inserirFilaEstatica(filaDaMorteEstatica* fila, Pessoas dados) 
{
    if (!filaCheiaEstatica(fila)) {
        fila->Pessoa[fila->FF] = dados;
        fila->FF = (fila->FF + 1) % MAX_FILA;
        fila->N++;
        return 1;
    } else {
        printf(RED "‚ö†Ô∏è A fila da morte est√° cheia! Nenhuma nova pessoa pode ser adicionada.\n" RESET);
        return 0;
    }
}

// Insere uma pessoa na fila din√¢mica üë§üîÑ
void inserirFilaDinamica(filaDaMorteDinamica* fila, Pessoas dados) 
{
    noDinamico* novo = (noDinamico*)malloc(sizeof(noDinamico));
    if (novo) {
        novo->Pessoa = dados;
        novo->prox = NULL;
        if (fila->Ult == NULL) {
            fila->Prim = novo;
        } else {
            fila->Ult->prox = novo;
        }
        fila->Ult = novo;
    }
}

// Fun√ß√£o para gerar professores aleat√≥rios com "crimes" engra√ßados
Pessoas gerarProfessores()
{
    Pessoas pessoa;
    strcpy(pessoa.nome, "");
    strcpy(pessoa.crime, "");
    int max = 19;
    int min = 0;

    // Lista de nomes
    char *nomes[] = {
        "Adriano Mendon√ßa Rocha",
        "Alessandra Aparecida Paulino",
        "Ana Cl√°udia Martinez",
        "Andre Luiz Naves de Oliveira",
        "Caio Augusto Rodrigues dos Santos",
        "Claudiney Ramos Tinoco",
        "Daniel Stefany Duarte Caetano",
        "Daniele Carvalho Oliveira",
        "Diego Nunes Molinos",
        "Gustavo de Lima Prado",
        "Mara Alves Soares",
        "Mirella Silva Junqueira",
        "Sara Luzia de Melo",
        "Thiago Henrique Pereira Silva",
        "Victor Sobreira",
        "V√¢nia de Fatima Lemes de Miranda",
        "K√°rita Barbosa dos Santos",
        "Thiago Pirola Ribeiro",
        "Danilo Elias de Oliveira",
        "Jair Rocha do Prado"};

    // Lista de crimes engra√ßados
    char *crimes[] = {
        "Passou 50 p√°ginas de dever para casa",
        "Explicou a mat√©ria com memes sem gra√ßa",
        "Usou piadas ruins para ensinar √°lgebra",
        "Esqueceu de apagar o quadro por tr√™s aulas seguidas",
        "Fez uma prova surpresa no dia do jogo da Copa",
        "Canta para acordar os alunos na aula de manh√£",
        "Prometeu revisar a prova e nunca o fez",
        "Escreveu com letra ileg√≠vel no quadro",
        "Usa slides com fontes min√∫sculas",
        "Atrasou a aula por discutir a s√©rie favorita",
        "Esqueceu de passar presen√ßa por um m√™s",
        "Deu aula no √∫ltimo dia antes das f√©rias",
        "Fez chamada no primeiro minuto de aula",
        "Disse que 'a prova vai ser f√°cil' e n√£o foi",
        "Colocou pergunta de mat√©ria n√£o ensinada na prova",
        "Usou v√≠deos de 2005 para explicar tecnologia",
        "Diz que vai soltar cedo, mas solta tarde",
        "Passou tarefa no grupo de WhatsApp √† meia-noite",
        "Exige trabalho em grupo e n√£o forma os grupos",
        "Usou o tempo da aula para contar hist√≥rias pessoais"};

    // Escolher um nome e crime aleat√≥rio
    strcpy(pessoa.nome, nomes[gerarNumeroAleatorio(min, max)]);
    pessoa.idade = gerarNumeroAleatorio(25, 65); // Idade entre 25 e 65
    strcpy(pessoa.crime, crimes[gerarNumeroAleatorio(min, max)]);
    return pessoa;
}
// Gera dados aleat√≥rios de uma pessoa üé≤üë§
Pessoas gerarDados() 
{
   Pessoas pessoa;
   gerarStringAleatoria(pessoa.nome, 22);
   pessoa.idade = gerarNumeroAleatorio(1 , 100);
   gerarStringAleatoria(pessoa.crime, 44);
   return pessoa;
}

// Gera um caractere aleat√≥rio (letra mai√∫scula ou min√∫scula) üé≤üî†
char gerarCaractereAleatorio() 
{
    int tipo = rand() % 2;
    if (tipo == 0) return 'a' + rand() % 26;
    else return 'A' + rand() % 26;
}

// Gera uma string aleat√≥ria com tamanho especificado üé≤‚úèÔ∏è
void gerarStringAleatoria(char *str, int tamanho) 
{
    for (int i = 0; i < tamanho; i++)
        str[i] = gerarCaractereAleatorio();
    str[tamanho] = '\0';
}

// Gera um n√∫mero aleat√≥rio entre min e max üé≤üî¢
int gerarNumeroAleatorio(int min, int max) {
    return rand() % (max - min + 1) + min;
}

// Exibe os condenados da fila est√°tica üë§‚öñÔ∏è‚ö∞Ô∏è
void exibirFilaEstatica(filaDaMorteEstatica* fila) 
{
    if (fila->N == 0) {
        printf(RED "‚ö†Ô∏è A fila est√°tica est√° vazia. Nenhum condenado √† espera...\n\n" RESET);
        return;
    }
    // ‚ö∞Ô∏è Exibe os condenados presentes na fila est√°tica
    printf(GREEN "üìú Condenados na fila est√°tica:\n\n" RESET);
    
    // Ajustando o √≠ndice para percorrer a fila corretamente
    int i = fila->IF;
    int count = 0; // Contador para limitar o n√∫mero de condenados exibidos

    while (count < fila->N) {
        // Numerando cada condenado na fila com destaque
        printf(YELLOW BOLD "üë§ Condenado #%d:\n" RESET, count + 1);
        
        // ü™¶ Exibindo os dados de cada condenado na fila
        printf(BLUE "ü™¶ Nome: %s\n" RESET, fila->Pessoa[i].nome);
        printf(CYAN "‚è≥ Idade: %d\n" RESET, fila->Pessoa[i].idade);
        printf(MAGENTA "üöî Crime: %s\n\n" RESET, fila->Pessoa[i].crime);
        
        // Incrementa o √≠ndice de forma circular
        i = (i + 1) % MAX_FILA; // Supondo MAX_FILA como o tamanho m√°ximo da fila
        
        count++;
    }

    // Mensagem de encerramento
    printf(GREEN BOLD "üè¥ Todos os condenados da fila est√°tica foram exibidos.\n\n" RESET);
}


// Exibe os condenados da fila din√¢mica üë§üîÑ‚öîÔ∏è
void exibirFilaDinamica(filaDaMorteDinamica* fila)
{
    if (fila->Prim == NULL) {
        printf(RED "‚ö†Ô∏è A fila din√¢mica est√° vazia. Nenhum condenado √† espera...\n\n" RESET);
        return;
    }
    // ‚öîÔ∏è Exibe os condenados presentes na fila din√¢mica
    noDinamico* aux = fila->Prim;
    int contador = 1; // Contador para numerar os condenados
    printf(GREEN "üìú Condenados na fila din√¢mica:\n\n" RESET);
    while (aux != NULL) {
        // Numerando cada condenado na fila com destaque
        printf(YELLOW BOLD "üë§ Condenado #%d:\n" RESET, contador++);
        // ü™¶ Exibindo os dados de cada condenado na fila
        printf(BLUE "ü™¶ Nome: %s\n" RESET, aux->Pessoa.nome);
        printf(CYAN "‚è≥ Idade: %d\n" RESET, aux->Pessoa.idade);
        printf(MAGENTA "üöî Crime: %s\n\n" RESET, aux->Pessoa.crime);
        aux = aux->prox;
    }
    // Mensagem de encerramento
    printf(GREEN BOLD "üè¥ Todos os condenados da fila din√¢mica foram exibidos.\n\n" RESET);
}


int removeFilaEstatica(filaDaMorteEstatica *fila, Pessoas *pessoa) 
{
    // Verifica se a fila √© nula ou est√° vazia
    if (fila == NULL || fila->N == 0)
        return 0;

    // Remove o elemento da posi√ß√£o inicial da fila e atualiza o √≠ndice de in√≠cio
    *pessoa = fila->Pessoa[fila->IF];
    fila->IF = (fila->IF + 1) % MAX_FILA;
    fila->N--;
    return 1;
}

int removeFilaDinamica(filaDaMorteDinamica *fila, Pessoas *pessoa)
{
  noDinamico* aux;
  if (fila == NULL || fila->Prim == NULL) // Verifica se a fila √© v√°lida e n√£o est√° vazia
    return 0;

  *pessoa = fila->Prim->Pessoa;              // Captura o valor do primeiro elemento
  aux = fila->Prim;                      // Ponteiro auxiliar para liberar mem√≥ria
  fila->Prim = fila->Prim->prox;          // Atualiza a cabe√ßa da fila
  if (fila->Prim == NULL)
    fila->Ult = NULL;                    // Se a fila ficou vazia, atualiza o final
  free(aux);                            // Libera a mem√≥ria do n√≥ removido
  return 1;
}

int consultaFilaEstatica(filaDaMorteEstatica *fila, Pessoas *pessoas) 
{
    // Verifica se a fila √© nula ou est√° vazia
    if (fila == NULL || fila->N == 0)
        return 0;
    
    // Consulta o elemento na posi√ß√£o inicial da fila
    *pessoas = (fila)->Pessoa[fila->IF];
    return 1; // Retorna 1 indicando sucesso na consulta
}

int consultaFilaDinamica(filaDaMorteDinamica *fila, Pessoas *pessoa)
{
  if (fila == NULL || fila->Prim == NULL) // Verifica se a fila √© v√°lida e n√£o est√° vazia
    return 0;
  *pessoa = fila->Prim->Pessoa;              // Retorna o valor do primeiro elemento
  return 1;
}

void analiseFilaEstatica(filaDaMorteEstatica *fila, Pessoas *pessoa, double* tempos)
{
  double start, finish;
  int cont = 0;
  int entradas[] = {1000, 3000, 5000, 10000, 25000};
  for (int i = 0; i < 5; i++)
  {
    start = (double) clock();
    for (int j = 0; j < entradas[i]; j++)
    {
        inserirFilaEstatica(fila, gerarDados());
    }
    finish = (double) clock();
    tempos[cont++] = finish - start;

    start = (double) clock();

    exibirFilaEstatica(fila);
    
    finish = (double) clock();
    tempos[cont++] = finish - start;

    start = (double) clock();
    for (int j = 0; j < entradas[i]; j++)
    {
        removeFilaEstatica(fila, pessoa);
    }
    finish = (double) clock();
    tempos[cont++] = finish - start;
  }

}

void analiseFilaDinamica(filaDaMorteDinamica *fila, Pessoas *pessoa, double* tempos) {
    double start, finish;
    int cont = 0;
    int entradas[] = {1000, 3000, 5000, 10000, 25000};
    
    for (int i = 0; i < 5; i++) {
        // Medindo o tempo de inser√ß√£o
        start = (double) clock();
        for (int j = 0; j < entradas[i]; j++) {
            inserirFilaDinamica(fila, gerarDados()); // Alterado para a fun√ß√£o de inser√ß√£o da fila din√¢mica
        }
        finish = (double) clock();
        tempos[cont++] = finish - start; // Armazenando o tempo de inser√ß√£o

        // Medindo o tempo de exibi√ß√£o
        start = (double) clock();
        exibirFilaDinamica(fila); // Alterado para a fun√ß√£o de exibi√ß√£o da fila din√¢mica
        finish = (double) clock();
        tempos[cont++] = finish - start; // Armazenando o tempo de exibi√ß√£o

        // Medindo o tempo de remo√ß√£o
        start = (double) clock();
        for (int j = 0; j < entradas[i]; j++) {
            removeFilaDinamica(fila, pessoa); // Alterado para a fun√ß√£o de remo√ß√£o da fila din√¢mica
        }
        finish = (double) clock();
        tempos[cont++] = finish - start; // Armazenando o tempo de remo√ß√£o
    }
}


// Fun√ß√£o para gerar uma sequ√™ncia de n√∫meros aleat√≥rios
void gerarSequencia(int *sequencia, int tamanho) {
    for (int i = 0; i < tamanho; i++) {
        sequencia[i] = rand() % 10; // N√∫meros de 0 a 9
    }
}

// Fun√ß√£o para exibir a sequ√™ncia para o condenado por um curto per√≠odo
void exibirSequencia(int *sequencia, int tamanho) {
    printf(GREEN "‚öîÔ∏è A sequ√™ncia de n√∫meros ser√° exibida por 3 segundos!\n\n" RESET);
    printf("\t\t");
    for (int i = 0; i < tamanho; i++) {
        printf(YELLOW "%d " RESET, sequencia[i]);
    }
    printf("\n");

    sleep(3);  // Espera 3 segundos para o condenado memorizar

    limparImediato();
    printf(RED "\nüí• A sequ√™ncia desapareceu! Voc√™ tem 7 segundos para adivinhar...\n" RESET);
}

// Fun√ß√£o para desafiar o condenado a adivinhar a sequ√™ncia
// Fun√ß√£o para desafiar o condenado a adivinhar a sequ√™ncia
int desafiarCondenado() {
    int sequencia[TAM_SEQUENCIA];
    int tentativa[TAM_SEQUENCIA];
    int acertou = 0;

    srand(time(NULL));  // Inicializa o gerador de n√∫meros aleat√≥rios

    // Gera a sequ√™ncia aleat√≥ria
    gerarSequencia(sequencia, TAM_SEQUENCIA);

    // Exibe a sequ√™ncia para o condenado por um curto tempo
    exibirSequencia(sequencia, TAM_SEQUENCIA);

    // Espera 7 segundos para o condenado tentar gerar a sequ√™ncia
    printf(CYAN "\n‚è≥ Voc√™ tem 10 segundos para tentar adivinhar a sequ√™ncia de n√∫meros. Comece agora!\n" RESET);
    sleep(1);  // Pequena pausa antes de come√ßar

    time_t start_time = time(NULL);  // Registra o tempo de in√≠cio

    // Tenta gerar a sequ√™ncia automaticamente at√© acertar ou o tempo acabar
    while (time(NULL) - start_time < 10) {  // Enquanto n√£o passar 7 segundos
        // Gera uma nova tentativa aleat√≥ria
        gerarSequencia(tentativa, TAM_SEQUENCIA);

        // Exibe a tentativa gerada para o condenado (opcional)
        printf(MAGENTA "Tentativa gerada: ");
        for (int i = 0; i < TAM_SEQUENCIA; i++) {
            printf("%d ", tentativa[i]);
        }
        printf("\n");

        // Verifica se a tentativa est√° correta
        int acerto = 1;
        for (int i = 0; i < TAM_SEQUENCIA; i++) {
            if (sequencia[i] != tentativa[i]) {
                acerto = 0;
                break;
            }
        }

        if (acerto) {
            acertou = 1;
            break;  // Se acertou, sai do loop
        }
    }

    if (acertou) {
        printf(GREEN "üéâ Parab√©ns, voc√™ acertou a sequ√™ncia! Voc√™ escapou da morte!\n" RESET);
        limpar();
    } else {
        printf(RED "üí• Que pena, voc√™ errou a sequ√™ncia. Foi removido da fila...\n" RESET);
        limpar();
    }

    return acertou;
}
