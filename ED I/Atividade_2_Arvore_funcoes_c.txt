// funcoes.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "funcoes.h"

// FunÃ§Ã£o para limpar a tela e aguardar a pressÃ£o de ENTER ğŸš¿â³
void limpar() 
{
    printf("\n\n%sğŸ›‘ %sPressione ENTER para continuar... %sğŸ›‘%s: ", LIGHT_CYAN, LIGHT_YELLOW, LIGHT_CYAN, RESET);
    getchar();  // â³ Espera a entrada do usuÃ¡rio
    #ifdef _WIN32
        system("cls");  // ğŸ–¥ï¸ Comando especÃ­fico para Windows para limpar a tela
    #else
        system("clear");  // ğŸ Comando especÃ­fico para Linux/Mac para limpar a tela
    #endif
}

// FunÃ§Ã£o para limpar o buffer de entrada ğŸ§¹
void limparbuffer() 
{
    int c;
    while ((c = getchar()) != '\n' && c != EOF);  // ğŸ§½ Limpa o buffer atÃ© encontrar o fim da linha ou o final do arquivo
}

// FunÃ§Ã£o para exibir mensagens de boas-vindas sobre Ã¡rvore binÃ¡ria ğŸŒ³ğŸŒ¿
void boasVindas() 
{
   printf("\n" LIME BOLD "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" RESET "\n");
   printf(LIME BOLD "â•‘" RESET " ğŸŒŸâœ¨ " BOLD PINK "Bem-vindo Ã  " RESET PINK BOLD "Ãrvore BinÃ¡ria de Busca" RESET PINK BOLD " âœ¨ğŸŒŸ " LIME BOLD "                             â•‘" RESET "\n");
   printf(LIME BOLD "â•‘" RESET " ğŸŒ³ğŸŒ¿ " LIGHT_YELLOW "Cada nÃ³ da Ã¡rvore guarda um info Ãºnico e organizado!" RESET LIME BOLD " ğŸŒ¿ğŸŒ³ " LIME BOLD "            â•‘" RESET "\n");
   printf(LIME BOLD "â•‘" RESET " ğŸŒ²ğŸŒ€ " MAGENTA "Explore a Ã¡rvore, insira, busque e descubra!" RESET LIME BOLD " ğŸŒ€ğŸŒ² " LIME BOLD "                    â•‘" RESET "\n");
   printf(LIME BOLD "â•‘" RESET " ğŸƒğŸ” " GREEN "A eficiÃªncia estÃ¡ nas suas ramificaÃ§Ãµes! Vamos comeÃ§ar?" RESET LIME BOLD " ğŸ”ğŸƒ " LIME BOLD "         â•‘" RESET "\n");
   printf(LIME BOLD "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" RESET "\n\n");

   limpar();  // ğŸš¿ Limpa a tela apÃ³s a mensagem de boas-vindas
}

// FunÃ§Ã£o para criar uma Ã¡rvore binÃ¡ria ğŸŒ³
No* criarArvore(int info)
{
    printf(LIME "\nğŸŒ¿ Inseri na arvore! info: %d\n" RESET, info); 
    return criarNo(info);  // ğŸŒ± Cria o nÃ³ raiz da Ã¡rvore
}

// FunÃ§Ã£o para criar um novo nÃ³ ğŸŒ¿
No* criarNo(int info)
{
    No* novoNo = (No*) malloc(sizeof(No));  // ğŸ’¾ Aloca memÃ³ria para o novo nÃ³
    if (novoNo == NULL)  // ğŸš¨ Verifica se a memÃ³ria foi alocada com sucesso
    {
        printf(RED BOLD "âŒ Erro ao alocar memÃ³ria!" RESET);
        exit(EXIT_FAILURE);  // âŒ Encerra o programa em caso de erro
    }
    novoNo->info = info;  // ğŸŒ± Atribui o valor ao novo nÃ³
    novoNo->direita = NULL;  // ğŸ‘‰ Inicializa o ponteiro da direita como NULL
    novoNo->esquerda = NULL;  // ğŸ‘ˆ Inicializa o ponteiro da esquerda como NULL
    return novoNo;  // ğŸŒ¿ Retorna o novo nÃ³
}

// FunÃ§Ã£o para inserir um info na Ã¡rvore binÃ¡ria ğŸŒ²
No* inserir(No* arvore, int info)
{      
    if (arvore == NULL)
        return arvore;  // ğŸŒ³ Se a Ã¡rvore estÃ¡ vazia, retorna NULL

    No* aux = arvore;  // ğŸ” VariÃ¡vel auxiliar para percorrer a Ã¡rvore

    while (aux != NULL)
    {
        if (info < aux->info)  // ğŸŒ¿ Insere na subÃ¡rvore esquerda se o info for menor
        {
            if (aux->esquerda == NULL)
            {
                aux->esquerda = criarNo(info);  // ğŸŒ± Cria um novo nÃ³ na esquerda
                printf(LIGHT_GREEN "\nğŸŒ± Inseri na esquerda! info: %d\n" RESET, info);  // ğŸŒ¿ Mensagem de inserÃ§Ã£o na esquerda
                return arvore;  // ğŸ”™ Retorna a Ã¡rvore apÃ³s inserÃ§Ã£o
            }
            aux = aux->esquerda;  // ğŸ‘ˆ AvanÃ§a para o nÃ³ Ã  esquerda
        }
        else  // ğŸ‘‰ Insere na subÃ¡rvore direita se o info for maior ou igual
        {
            if (aux->direita == NULL)
            {
                aux->direita = criarNo(info);  // ğŸŒ± Cria um novo nÃ³ na direita
                printf(LIGHT_BLUE "\nğŸŒ³ Inseri na direita! info: %d\n" RESET, info);  // ğŸŒ³ Mensagem de inserÃ§Ã£o na direita
                return arvore;  // ğŸ”™ Retorna a Ã¡rvore apÃ³s inserÃ§Ã£o
            }
            aux = aux->direita;  // ğŸ‘‰ AvanÃ§a para o nÃ³ Ã  direita
        }
    }
    return arvore;  // ğŸ”™ Retorna a Ã¡rvore completa apÃ³s a inserÃ§Ã£o
}

// FunÃ§Ã£o para percorrer a Ã¡rvore usando o algoritmo Morris ğŸŒ²
void morrisTraversal(No* arvore) { 
    No* atual = arvore;  // ğŸŒ³ Inicializa o nÃ³ atual

    while (atual != NULL) {
        if (atual->esquerda == NULL) {
            // Se nÃ£o houver filho Ã  esquerda, processa o nÃ³ e vai para a direita
            printf(LIME "\nğŸŒ³ Visitando nÃ³: %d\n" RESET, atual->info);
            atual = atual->direita;  // ğŸ‘‰ AvanÃ§a para a direita
        } else {
            // Encontrar o predecessor in-order do nÃ³ atual
            No* predecessor = atual->esquerda;  // ğŸŒ¿ Inicializa o predecessor
            while (predecessor->direita != NULL && predecessor->direita != atual) {
                predecessor = predecessor->direita;  // ğŸ‘‰ AvanÃ§a para a direita do predecessor
            }

            if (predecessor->direita == NULL) {
                // Criar um link temporÃ¡rio para voltar ao nÃ³ atual apÃ³s processar a subÃ¡rvore esquerda
                predecessor->direita = atual;  // ğŸ”— Estabelece um link temporÃ¡rio
                printf(LIME "\nğŸŒ¿ Visitando nÃ³: %d\n" RESET, atual->info);
                atual = atual->esquerda;  // ğŸ‘ˆ Vai para a subÃ¡rvore esquerda
            } else {
                // Remover o link temporÃ¡rio e processar o nÃ³ atual
                predecessor->direita = NULL;  // âŒ Remove o link temporÃ¡rio
                printf(LIME "\nğŸŒ² Visitando nÃ³: %d\n" RESET, atual->info);
                atual = atual->direita;  // ğŸ‘‰ AvanÃ§a para a direita
            }
        }
    }
}

// FunÃ§Ã£o para encontrar o nÃ³ mÃ­nimo na subÃ¡rvore ğŸŒ±
No* encontrarMinimo(No* arvore) {
    while (arvore && arvore->esquerda != NULL) {
        arvore = arvore->esquerda;  // ğŸ‘‰ Percorre atÃ© encontrar o nÃ³ mais Ã  esquerda
    }
    return arvore;  // ğŸŒ¿ Retorna o nÃ³ mÃ­nimo
}

// FunÃ§Ã£o para remover um nÃ³ da Ã¡rvore de forma iterativa ğŸŒ³
No* remover(No* arvore, int valor) {
    No* pai = NULL;  // ğŸ‘¨â€ğŸ‘¦ Inicializa o pai como NULL
    No* atual = arvore;  // ğŸŒ³ Inicializa o nÃ³ atual

    // Encontrar o nÃ³ a ser removido e seu pai
    while (atual != NULL && atual->info != valor) {
        pai = atual;  // ğŸ“ Atualiza o pai
        if (valor < atual->info) {
            atual = atual->esquerda;  // ğŸ‘ˆ AvanÃ§a para a esquerda
        } else {
            atual = atual->direita;  // ğŸ‘‰ AvanÃ§a para a direita
        }
    }

    // Se o nÃ³ nÃ£o foi encontrado
    if (atual == NULL) {
        printf("NÃ³ com valor %d nÃ£o encontrado.\n", valor);  // âš ï¸ Mensagem de erro
        return arvore;  // ğŸ”™ Retorna a Ã¡rvore sem alteraÃ§Ãµes
    }

    // Caso 1: NÃ³ com apenas um filho ou sem filhos ğŸŒ¿
    if (atual->esquerda == NULL) {
        if (pai == NULL) {
            // Se nÃ£o houver pai, significa que estamos removendo a raiz
            No* temp = atual->direita;  // ğŸ‘‰ Guarda o filho Ã  direita
            free(atual);  // ğŸŒ± Libera a memÃ³ria do nÃ³
            return temp;  // Retorna o filho Ã  direita ou NULL se nÃ£o houver
        } else if (pai->esquerda == atual) {
            pai->esquerda = atual->direita;  // Conecta o filho Ã  esquerda
        } else {
            pai->direita = atual->direita;  // Conecta o filho Ã  direita
        }
        free(atual);  // ğŸŒ± Libera a memÃ³ria do nÃ³
    } else if (atual->direita == NULL) {
        // Caso 2: NÃ³ com apenas filho Ã  esquerda ğŸŒ³
        if (pai == NULL) {
            No* temp = atual->esquerda;  // ğŸ‘‰ Guarda o filho Ã  esquerda
            free(atual);  // ğŸŒ± Libera a memÃ³ria do nÃ³
            return temp;  // Retorna o filho Ã  esquerda ou NULL se nÃ£o houver
        } else if (pai->esquerda == atual) {
            pai->esquerda = atual->esquerda;  // Conecta o filho Ã  esquerda
        } else {
            pai->direita = atual->esquerda;  // Conecta o filho Ã  direita
        }
        free(atual);  // ğŸŒ± Libera a memÃ³ria do nÃ³
    } else {
        // Caso 3: NÃ³ com dois filhos ğŸŒ³
        No* sucessor = encontrarMinimo(atual->direita);  // ğŸŒ± Encontra o nÃ³ mÃ­nimo na subÃ¡rvore direita
        int valorSucessor = sucessor->info;  // Armazena o valor do sucessor
        remover(arvore, valorSucessor);  // Remove o sucessor
        atual->info = valorSucessor;  // Atribui o valor do sucessor ao nÃ³ atual
    }

    return arvore;  // ğŸ”™ Retorna a Ã¡rvore apÃ³s a remoÃ§Ã£o
}

// FunÃ§Ã£o para liberar a memÃ³ria da Ã¡rvore ğŸŒ³ğŸ§¹
void liberarArvore(No* arvore) {
    if (arvore != NULL) {
        liberarArvore(arvore->esquerda);  // ğŸ‘ˆ Libera a subÃ¡rvore esquerda
        liberarArvore(arvore->direita);  // ğŸ‘‰ Libera a subÃ¡rvore direita
        printf(GREEN "ğŸŒ± Liberando nÃ³ com valor: %d ğŸŒ±\n" RESET, arvore->info);
        free(arvore);  // ğŸŒ± Libera o nÃ³ atual
    }
}