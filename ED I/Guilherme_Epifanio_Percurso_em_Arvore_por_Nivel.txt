#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Estrutura de um elemento da Ã¡rvore de busca ğŸ”—
typedef struct Elemento {
    int valor;          // Valor armazenado no elemento ğŸ”¢
    struct Elemento* esq;   // Ponteiro para o elemento Ã  esquerda ğŸ‘ˆ
    struct Elemento* dir;   // Ponteiro para o elemento Ã  direita ğŸ‘‰
} *ArvoreBinaria;

// FunÃ§Ã£o para criar uma Ã¡rvore vazia ğŸŒ±
ArvoreBinaria criarArvoreVazia() {
    return NULL;  // Retorna uma Ã¡rvore sem nenhum elemento ğŸŒ¿
}

// FunÃ§Ã£o para inserir um valor na Ã¡rvore binÃ¡ria ğŸ”§
ArvoreBinaria adicionarElemento(ArvoreBinaria raiz, const int valor) {
    // Cria um novo elemento ğŸ§©
    ArvoreBinaria novoElemento = (ArvoreBinaria)malloc(sizeof(struct Elemento));
    if (novoElemento == NULL) return raiz;  // Verifica se a alocaÃ§Ã£o falhou ğŸ˜±
    novoElemento->valor = valor;
    novoElemento->esq = NULL;
    novoElemento->dir = NULL;

    // Se a Ã¡rvore estÃ¡ vazia, o novo elemento se torna a raiz ğŸŒ±
    if (raiz == NULL) return novoElemento;

    // Encontra a posiÃ§Ã£o para inserir o novo elemento ğŸ§­
    ArvoreBinaria atual = raiz;
    ArvoreBinaria anterior = NULL;
    while (atual != NULL) {
        anterior = atual;
        if (valor < atual->valor) {
            atual = atual->esq;  // Vai para a subÃ¡rvore esquerda ğŸ‘ˆ
        } else {
            atual = atual->dir;  // Vai para a subÃ¡rvore direita ğŸ‘‰
        }
    }

    // Insere o novo elemento no local adequado ğŸ”‘
    if (valor < anterior->valor) {
        anterior->esq = novoElemento;  // Insere Ã  esquerda ğŸ‘ˆ
    } else {
        anterior->dir = novoElemento;  // Insere Ã  direita ğŸ‘‰
    }

    return raiz;
}

// FunÃ§Ã£o para percorrer a Ã¡rvore por nÃ­veis (breadth-first) ğŸ”„
void percorrerPorNiveis(ArvoreBinaria raiz) {
    if (raiz == NULL) return;
    
    ArvoreBinaria fila[500];  // Fila para armazenar os elementos ğŸŒ
    int inicioFila = 0, finalFila = 0;
    fila[finalFila++] = raiz;
    int espacamento = 1;  // Controla o espaÃ§amento da saÃ­da ğŸ“

    while (inicioFila < finalFila) {
        ArvoreBinaria elementoAtual = fila[inicioFila++];  // Retira o elemento da frente da fila ğŸš¶
        
        if (!espacamento)
            printf(" ");  // Adiciona um espaÃ§o entre os valores exibidos â–
        printf("%d", elementoAtual->valor);  // Mostra o valor do elemento ğŸŒŸ
        espacamento = 0;

        // Adiciona os filhos Ã  fila ğŸ‘ˆğŸ‘‰
        if (elementoAtual->esq) fila[finalFila++] = elementoAtual->esq;
        if (elementoAtual->dir) fila[finalFila++] = elementoAtual->dir;
    }
}

// FunÃ§Ã£o para liberar a memÃ³ria alocada para a Ã¡rvore ğŸŒ±
void liberarArvore(ArvoreBinaria raiz) {
    if (raiz != NULL) {
        liberarArvore(raiz->esq);  // Libera a subÃ¡rvore esquerda ğŸ‘ˆ
        liberarArvore(raiz->dir);   // Libera a subÃ¡rvore direita ğŸ‘‰
        free(raiz);  // Libera o elemento atual ğŸ§ 
    }
}

// FunÃ§Ã£o para processar as interaÃ§Ãµes do usuÃ¡rio ğŸ“
void processarCasos(int totalCasos) {
    for (int caso = 1; caso <= totalCasos; caso++) {
        int numeroElementos;
        scanf("%d", &numeroElementos);  // LÃª a quantidade de elementos para a Ã¡rvore ğŸ“Š
        
        ArvoreBinaria raiz = criarArvoreVazia();  // Inicializa uma nova Ã¡rvore ğŸŒ±
        
        for (int k = 0; k < numeroElementos; k++) {
            int valor;
            scanf("%d", &valor);  // LÃª o valor do elemento a ser inserido ğŸ“¥
            raiz = adicionarElemento(raiz, valor);  // Insere o valor na Ã¡rvore ğŸ› ï¸
        }
        
        printf("Case %d:\n", caso);  // Exibe o nÃºmero do case atual ğŸ§©
        percorrerPorNiveis(raiz);  // Realiza o percurso em largura ğŸ”„
        printf("\n\n");
        
        liberarArvore(raiz);  // Libera a memÃ³ria apÃ³s o uso da Ã¡rvore ğŸ§ 
    }
}

// FunÃ§Ã£o principal ğŸš€
int main() {
    int casosTeste;
    scanf("%d", &casosTeste);  // LÃª o nÃºmero de cases de teste ğŸ“¥
    
    processarCasos(casosTeste);  // Inicia o processamento dos cases ğŸ“

    return 0;  // Termina o programa ğŸ
}
