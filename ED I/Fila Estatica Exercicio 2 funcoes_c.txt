#include <stdio.h>
#include <stdlib.h>
#include "funcoes.h"

// ğŸŒŸ FunÃ§Ã£o para verificar se a fila estÃ¡ vazia
int E_vazia(Fila *Ptf) {
    // Retorna 1 se a fila estiver vazia (N == 0), caso contrÃ¡rio retorna 0
    return (Ptf->N == 0) ? 1 : 0;
}

// ğŸ  FunÃ§Ã£o para verificar se a fila estÃ¡ cheia
int E_cheia(Fila *Ptf) {
    // Retorna 1 se a fila estiver cheia (N == MAX_FILA), caso contrÃ¡rio retorna 0
    return (Ptf->N == MAX_FILA) ? 1 : 0;
}

// ğŸ†• FunÃ§Ã£o para criar uma nova fila
Fila *Cria_fila(void) {
    Fila *Ptf;
    Ptf = (Fila *)malloc(sizeof(Fila)); // Aloca memÃ³ria para a nova fila
    if (Ptf != NULL) {
        // Inicializa os Ã­ndices e o contador de elementos
        Ptf->IF = 0;
        Ptf->FF = 0;
        Ptf->N = 0;
    }
    return Ptf; // Retorna o ponteiro para a nova fila
}

// â• FunÃ§Ã£o para inserir um elemento na fila
Fila *Insere_fila(Fila *Ptf, int elem) {
    // Verifica se a fila Ã© nula ou estÃ¡ cheia
    if (Ptf == NULL || Ptf->N == MAX_FILA)
        return Ptf;
    
    // Insere o elemento na posiÃ§Ã£o final da fila e atualiza o Ã­ndice de final
    Ptf->valor[Ptf->FF] = elem;
    Ptf->FF = (Ptf->FF + 1) % MAX_FILA;
    Ptf->N++;
    return Ptf;
}

// â– FunÃ§Ã£o para remover um elemento da fila
Fila *Remove_fila(Fila *Ptf, int *elem) {
    // Verifica se a fila Ã© nula ou estÃ¡ vazia
    if (Ptf == NULL || Ptf->N == 0)
        return Ptf;

    // Remove o elemento da posiÃ§Ã£o inicial da fila e atualiza o Ã­ndice de inÃ­cio
    *elem = Ptf->valor[Ptf->IF];
    Ptf->IF = (Ptf->IF + 1) % MAX_FILA;
    Ptf->N--;
    return Ptf;
}

// ğŸ” FunÃ§Ã£o para consultar o prÃ³ximo elemento da fila
int Consulta_fila(Fila *Ptf, int *elem) {
    // Verifica se a fila Ã© nula ou estÃ¡ vazia
    if (Ptf == NULL || Ptf->N == 0)
        return 0;
    
    // Consulta o elemento na posiÃ§Ã£o inicial da fila
    *elem = (Ptf)->valor[Ptf->IF];
    return 1; // Retorna 1 indicando sucesso na consulta
}

// ğŸ—‘ï¸ FunÃ§Ã£o para liberar a memÃ³ria da fila
Fila *Libera_fila(Fila *Ptf) {
    // Verifica se a fila Ã© nula
    if (Ptf == NULL)
        return Ptf;
    free(Ptf); // Libera a memÃ³ria alocada para a fila
    return NULL; // Retorna NULL para indicar que a fila foi liberada
}

// ğŸ”— FunÃ§Ã£o para mesclar duas filas em uma terceira
void Mesclar_filas(Fila *F1, Fila *F2, Fila *F3) {
    int elem1, elem2;

    // Enquanto ambas as filas F1 e F2 nÃ£o estiverem vazias
    while (!E_vazia(F1) && !E_vazia(F2)) {
        // Consulta os elementos na frente de cada fila
        Consulta_fila(F1, &elem1);
        Consulta_fila(F2, &elem2);

        // Explica o estado atual das filas e os elementos a serem comparados
        printf(GREEN "ğŸ” Consulta F1: " RESET RED "%d " PURPLE "|" GREEN " Consulta F2: " RESET RED "%d\n", elem1, elem2);

        // Compara os elementos e decide qual inserir na fila F3
        if (elem1 >= elem2) {
            printf(BLUE "\nğŸ“¥ Elemento " RESET RED "%d " BLUE "de F1 Ã© maior ou igual ao elemento " RESET RED "%d " BLUE "de F2. Inserindo " RESET RED "%d " BLUE "em F3.\n" RESET, elem1, elem2, elem1);
            Insere_fila(F3, elem1);  // Insere o elemento maior ou igual em F3
            Remove_fila(F1, &elem1); // Remove o elemento inserido de F1
            printf("\n");
            printf(YELLOW "ğŸ—‘ï¸  Elemento" RESET RED "%d " YELLOW "removido de F1. Fila F1 apÃ³s remoÃ§Ã£o: " RESET, elem1);
            Imprime_fila(F1); // Imprime o estado atualizado de F1
        } else {
            printf(BLUE "\nğŸ“¥ Elemento " RESET RED "%d " BLUE "de F2 Ã© maior que o elemento " RESET RED "%d " BLUE "de F1. Inserindo " RESET RED "%d " BLUE "em F3.\n" RESET, elem2, elem1, elem2);
            Insere_fila(F3, elem2);  // Insere o elemento menor em F3
            Remove_fila(F2, &elem2); // Remove o elemento inserido de F2
            printf("\n");
            printf(YELLOW "ğŸ—‘ï¸  Elemento" RESET RED "%d " YELLOW "removido de F2. Fila F2 apÃ³s remoÃ§Ã£o: " RESET, elem2);
            Imprime_fila(F2); // Imprime o estado atualizado de F2
        }
        limpar();
    }

    // Processa os elementos restantes em F1, se houver
    while (!E_vazia(F1)) {
        Remove_fila(F1, &elem1);
        printf(GREEN "\nğŸ“¥ Elemento " RESET RED "%d " GREEN "removido de F1 e inserido em F3.\n" RESET, elem1);
        Insere_fila(F3, elem1);
        printf("\n");
        printf(YELLOW "ğŸ—‘ï¸  Fila F1 apÃ³s remoÃ§Ã£o: " RESET);
        Imprime_fila(F1); // Imprime o estado atualizado de F1
        limpar();
    }

    // Processa os elementos restantes em F2, se houver
    while (!E_vazia(F2)) {
        Remove_fila(F2, &elem2);
        printf(GREEN "\nğŸ“¥ Elemento " RESET RED "%d " GREEN "removido de F2 e inserido em F3.\n" RESET, elem2);
        Insere_fila(F3, elem2);
        printf("\n");
        printf(YELLOW "ğŸ—‘ï¸  Fila F2 apÃ³s remoÃ§Ã£o: " RESET);
        Imprime_fila(F2); // Imprime o estado atualizado de F2
        limpar();
    }

    // Exibe o estado final da fila F3 apÃ³s a mesclagem
    printf(CYAN "ğŸš€ Fila F3 apÃ³s a mesclagem: " RESET);
    Imprime_fila(F3); // Imprime o estado final de F3
}

// ğŸ“‹ FunÃ§Ã£o para imprimir os elementos da fila
void Imprime_fila(Fila *fila) {
    // Verifica se a fila estÃ¡ vazia
    if (E_vazia(fila)) {
        printf(CYAN "ğŸ›‘ A fila estÃ¡ vazia. %s\n", RESET); // Mensagem de fila vazia em ciano
        return;
    }

    int i = fila->IF;
    printf("| ");
    // Itera sobre os elementos da fila e imprime cada um
    for (int count = 0; count < fila->N; count++) {
        printf(GREEN "%2d " RESET, fila->valor[i]); // Elementos da fila em verde
        printf("| " RESET);
        i = (i + 1) % MAX_FILA;
    }
    printf("\n");
}

// ğŸ§¹ FunÃ§Ã£o para limpar a tela
void limpar() {
    // Mensagem para o usuÃ¡rio pressionar ENTER
    printf("\n%sğŸ›‘ %sPressione ENTER para continuar... %sğŸ›‘%s: ", LIGHT_CYAN, ORANGE, LIGHT_CYAN, RESET);

    // Pausa atÃ© o usuÃ¡rio pressionar ENTER
    getchar();

    #ifdef _WIN32
        system("cls");  // Comando para limpar a tela no Windows
    #else
        system("clear");  // Comando para limpar a tela em Unix/Linux
    #endif
}
// FunÃ§Ã£o para exibir mensagens de boas-vindas
void boasVindas() {
    printf("\n" BLUE BOLD "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" RESET "\n");
    printf(BLUE BOLD "â•‘" RESET " ğŸš€ğŸ“¥ " GREEN BOLD "Bem-vindo ao" RESET " " CYAN BOLD "Gerenciador de Filas" GREEN " ğŸ“¥ğŸš€ " BLUE BOLD "                               â•‘" RESET "\n");
    printf(BLUE BOLD "â•‘" RESET " ğŸƒâ€â™‚ï¸ğŸ”„ " LIGHT_GREEN "Prepare-se para manipular suas filas com eficiÃªncia!" BLUE " ğŸ”„ğŸƒâ€â™‚ï¸ " BLUE BOLD "          â•‘" RESET "\n");
    printf(BLUE BOLD "â•‘" RESET " ğŸ“Šâœ… " YELLOW "Organize, insira e remova elementos com facilidade!" BLUE " âœ…ğŸ“Š " BLUE BOLD "             â•‘" RESET "\n");
    printf(BLUE BOLD "â•‘" RESET " ğŸ’¡ğŸ—ƒï¸ " LIGHT_CYAN "Vamos otimizar seu gerenciamento de dados em filas!" BLUE " ğŸ—ƒï¸ğŸ’¡ " BLUE BOLD "             â•‘" RESET "\n");
    printf(BLUE BOLD "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" RESET "\n\n");
}
