//funcoes.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "funcoes.h"

// Fun√ß√£o para limpar a tela e aguardar a press√£o de ENTER
void limpar() {
    // Solicita ao usu√°rio para pressionar ENTER e limpar a tela
    printf("\n\n%süõë %sPressione ENTER para continuar... %süõë%s: ", LIGHT_CYAN, LIGHT_YELLOW, LIGHT_CYAN, RESET);
    getchar();  // Espera a entrada do usu√°rio
    #ifdef _WIN32
        system("cls");  // Comando espec√≠fico para Windows para limpar a tela
    #else
        system("clear");  // Comando espec√≠fico para Linux/Mac para limpar a tela
    #endif
}

// Fun√ß√£o para limpar o buffer de entrada
void limparbuffer() {
    int c;
    // Remove todos os caracteres do buffer de entrada at√© o fim da linha ou o EOF
    while ((c = getchar()) != '\n' && c != EOF);
}

// Cria uma lista duplamente encadeada de Emojis
Emoji *Cria_lista(ListaDuplamenteEncadeada *lista) {
    lista->cauda = NULL;  // Inicializa o ponteiro da cauda como NULL, indicando que a lista est√° vazia
    return NULL;         // Retorna NULL, pois a lista rec√©m-criada ainda n√£o tem elementos
}


// Fun√ß√£o de inser√ß√£o de emoji
Emoji* Insere(ListaDuplamenteEncadeada *ptL) {
    char aux2[16];        // Array para armazenar o s√≠mbolo do emoji temporariamente
    Emoji* pt;            // Ponteiro para o novo Emoji a ser inserido
    // Alocando mem√≥ria para o novo emoji
    pt = (Emoji*)malloc(sizeof(Emoji));
    if(pt == NULL) {
        // Mensagem de erro se a aloca√ß√£o de mem√≥ria falhar
        printf(RED "‚ùå Erro: Falha ao alocar mem√≥ria!\n" RESET);
        return ptL->cabeca;  // Retorna a cabe√ßa da lista sem modifica√ß√µes
    }
    // Solicitando dados do Emoji ao usu√°rio
    printf(BLUE "üé≤--- Dados do Emoji ---üé≤\n" RESET); // Usando BLUE para t√≠tulos
    printf(YELLOW "üôÇ Emoji:\033[0m ");
    scanf("%s", aux2);
    limparbuffer();  // Limpa o buffer de entrada ap√≥s a leitura
    strcpy(pt->simbolo, aux2);  // Copia o s√≠mbolo inserido para o novo Emoji
    // Solicitando e validando a popularidade do Emoji
    do {
        printf(YELLOW "üî• Popularidade:\033[0m ");
        scanf("%d", &pt->popularidade);
        limparbuffer();  // Limpa o buffer de entrada ap√≥s a leitura
    } while(pt->popularidade < 0);  // Garante que a popularidade n√£o seja negativa
    // Inicializa os ponteiros pr√≥ximo e anterior do novo Emoji
    pt->prox = NULL;
    pt->ant = NULL;
    // Insere o novo Emoji no final da lista
    if (ptL->cauda == NULL) {
        // Se a lista estiver vazia, o novo Emoji √© tanto a cabe√ßa quanto a cauda
        ptL->cabeca = pt;
        ptL->cauda = pt;
    } else {
        // Se a lista j√° tiver elementos, ajusta os ponteiros para adicionar o Emoji ao final
        ptL->cauda->prox = pt;
        pt->ant = ptL->cauda;
        ptL->cauda = pt;
    }

    int cont = 0;
    // Exibindo a lista atualizada
    printf("\n" BLUE "üî¢--- Lista Atualizada ---\n" RESET);
    pt = ptL->cabeca;  // Come√ßa a exibi√ß√£o a partir da cabe√ßa da lista
    while(pt != NULL) {
        // Exibe o n√∫mero, s√≠mbolo e popularidade do Emoji atual
        printf(YELLOW "%d¬∫ üìõ Emoji " RESET, ++cont); // Estilo para o contador
        printf(GREEN "= %s" RESET, pt->simbolo); // Usando GREEN para o s√≠mbolo
        printf(MAGENTA "üåü = %d" RESET, pt->popularidade); // Usando MAGENTA para a popularidade
        pt = pt->prox;  // Move para o pr√≥ximo Emoji na lista
        if (pt != NULL) {
            printf(", ");  // Adiciona uma v√≠rgula entre Emojis, se houver mais
        }
    }
    printf("\n");

    // Retorna a cabe√ßa da lista ap√≥s a inser√ß√£o
    return ptL->cabeca;
}


void Exibe(ListaDuplamenteEncadeada *ptL) {
    Emoji* pt = ptL->cabeca;

    if (pt == NULL) {
        printf(RED "\n‚ùå Lista vazia.\n" RESET); // Emoji para indicar lista vazia
        return;
    }

    printf("\n" BLUE "üìã --- Lista de Emojis ---\n" RESET); // Emoji de lista
    int cont = 0;
    while (pt != NULL) {
        printf(YELLOW "%d¬∫ üìõ Emoji " RESET, ++cont); // Estilo para o contador
        printf(GREEN "= %s" RESET, pt->simbolo); // Emoji para cada entrada de s√≠mbolo
        printf(MAGENTA " üåü = %d" RESET, pt->popularidade); // Emoji para a popularidade
        pt = pt->prox;
        if (pt != NULL) {
            printf(", ");
        }
    }
    printf("\n");
}


// Fun√ß√£o para remover Emojis com uma determinada popularidade
Emoji* Remove_elem(ListaDuplamenteEncadeada* Ptl, int popularidade, int *flag) {
    Emoji* atual = Ptl->cabeca;  // Inicia da cabe√ßa da lista
    Emoji* aux;
    *flag = 0;  // Inicializa a flag de remo√ß√£o como 0 (nenhum Emoji removido ainda)
    // Percorre a lista procurando Emojis com a popularidade especificada
    while (atual != NULL) {
        if (atual->popularidade == popularidade) {
            printf(BLUE "\nüóëÔ∏è Removendo Emoji(s) com popularidade %d...\n\n" RESET, popularidade);
            // Ajusta os ponteiros da lista duplamente encadeada para remover o Emoji
            if (atual == Ptl->cabeca) {
                Ptl->cabeca = atual->prox;  // Atualiza a cabe√ßa da lista
                if (Ptl->cabeca != NULL) {
                    Ptl->cabeca->ant = NULL;  // Atualiza o ponteiro anterior da nova cabe√ßa
                }
            } else {
                atual->ant->prox = atual->prox;  // Atualiza o pr√≥ximo do n√≥ anterior
                if (atual->prox != NULL) {
                    atual->prox->ant = atual->ant;}  // Atualiza o anterior do n√≥ pr√≥ximo
            }
            if (atual == Ptl->cauda) {
                Ptl->cauda = atual->ant;}  // Atualiza a cauda da lista
            // Libera a mem√≥ria do Emoji removido
            aux = atual;
            atual = atual->prox;
            free(aux);
            *flag = 1;  // Atualiza a flag indicando que um Emoji foi removido
            printf(GREEN "‚úÖ Emoji(s) com popularidade %d removido com sucesso!\n" RESET, popularidade);
        } else {
            atual = atual->prox;}  // Move para o pr√≥ximo Emoji
    }
    // Mensagem se nenhum Emoji com a popularidade especificada foi encontrado
    if (*flag == 0) {
        printf(YELLOW "‚ùå Nenhum Emoji com popularidade %d encontrado para remo√ß√£o.\n" RESET, popularidade);
    }
    return Ptl->cabeca;  // Retorna a nova cabe√ßa da lista
}

// Fun√ß√£o para consultar um Emoji pelo s√≠mbolo
int Consulta_elem(ListaDuplamenteEncadeada* Ptl, const char* emoji) {
    Emoji* atual = Ptl->cabeca;  // Inicia da cabe√ßa da lista

    // Percorre a lista procurando o Emoji com o s√≠mbolo especificado
    while (atual != NULL && strcmp(atual->simbolo, emoji) != 0) {
        atual = atual->prox;
    }

    // Verifica se o Emoji foi encontrado
    if (atual == NULL) {
        printf("\n%süíîüò¢ %sEmoji n√£o encontrado! %süò≠üíß %s\n", RED, CYAN, BLUE, RESET);
        return 0;  // Retorna 0 se o Emoji n√£o foi encontrado
    } else {
        printf("\n%süòä‚≠ê %sEmoji encontrado com sucesso! %süéâ‚≠ê %s\n\n", RED, GREEN, BLUE, RESET);
        // Exibe detalhes do Emoji encontrado
        printf("%süåüüî• %sEmoji: |------[%s]------| %süöÄüåà %s\n", RED, CYAN, atual->simbolo, MAGENTA, RESET);
        printf("%süí•üí´ %sPopularidade: %d %s‚ö°üåª %s\n\n", YELLOW, BLUE, atual->popularidade, MAGENTA, RESET);
        return 1;  // Retorna 1 se o Emoji foi encontrado
    }
}

// Fun√ß√£o para liberar toda a mem√≥ria usada pela lista
Emoji* Libera_lista(ListaDuplamenteEncadeada* Ptl) {
    Emoji* aux = Ptl->cabeca;  // Inicia da cabe√ßa da lista

    // Percorre a lista liberando a mem√≥ria de cada Emoji
    while (aux != NULL) {
        Emoji* temp = aux;
        aux = aux->prox;
        free(temp);
    }

    Ptl->cauda = NULL;  // Define a cauda como NULL ap√≥s a libera√ß√£o da mem√≥ria
    return Ptl->cabeca;  // Retorna a nova cabe√ßa da lista (que deve ser NULL)
}

// Fun√ß√£o para trocar os dados de dois Emojis
void trocar(Emoji* a, Emoji* b) {
    int tempPopularidade = a->popularidade;  // Armazena a popularidade de 'a' temporariamente
    char tempSimbolo[16];
    strcpy(tempSimbolo, a->simbolo);  // Armazena o s√≠mbolo de 'a' temporariamente

    a->popularidade = b->popularidade;  // Troca a popularidade de 'a' com 'b'
    strcpy(a->simbolo, b->simbolo);  // Troca o s√≠mbolo de 'a' com 'b'

    b->popularidade = tempPopularidade;  // Define a popularidade de 'b' para o valor original de 'a'
    strcpy(b->simbolo, tempSimbolo);  // Define o s√≠mbolo de 'b' para o valor original de 'a'
}


// Fun√ß√£o de ordena√ß√£o Stooge Sort para a lista de Emojis
void stoogeSort(ListaDuplamenteEncadeada* Ptl, Emoji* l, Emoji* h) {
    // Caso base: se a lista for pequena ou os elementos forem adjacentes ou iguais
    if (l == NULL || h == NULL || l == h) return;

    // Verifica se √© necess√°rio trocar os Emojis
    if (l->popularidade > h->popularidade) {
        trocar(l, h);  // Troca os dados de l e h
    }

    // Calcula o tamanho da sublista entre l e h
    int tamanho = 1;
    Emoji* temp = l;
    while (temp != h) {
        tamanho++;
        temp = temp->prox;
    }

    // Divide e ordena recursivamente se a lista tiver mais que 2 elementos
    if (tamanho > 2) {
        int umTerco = tamanho / 3;

        // Determina o fim do primeiro ter√ßo
        Emoji* fimPrimeiroTerco = l;
        for (int i = 0; i < umTerco; i++) {
            fimPrimeiroTerco = fimPrimeiroTerco->prox;
        }

        // Determina o in√≠cio do √∫ltimo ter√ßo
        Emoji* inicioUltimoTerco = h;
        for (int i = 0; i < umTerco; i++) {
            inicioUltimoTerco = inicioUltimoTerco->ant;
        }

        // Ordena o primeiro ter√ßo da lista
        stoogeSort(Ptl, l, inicioUltimoTerco);

        // Ordena o √∫ltimo ter√ßo da lista
        stoogeSort(Ptl, fimPrimeiroTerco, h);

        // Ordena novamente o primeiro ter√ßo da lista
        stoogeSort(Ptl, l, inicioUltimoTerco);
    }
}

void ordenarLista(ListaDuplamenteEncadeada* Ptl) {
    if (Ptl->cabeca && Ptl->cauda) {
        printf(CYAN "üîÑ Lista Inicial:\n" RESET);
        Exibe(Ptl);  // Exibe a lista inicial
        printf("\n");

        limpar();  // Limpa a tela

        printf(YELLOW "üöÄ Iniciando a ordena√ß√£o com Stooge Sort...\n\n" RESET);
        limpar(); 
        stoogeSort(Ptl, Ptl->cabeca, Ptl->cauda);  // Chama o Stooge Sort

        printf(GREEN "‚úÖ Lista Ordenada:\n" RESET);
        Exibe(Ptl);  // Exibe a lista ordenada
        printf("\n");
    } else {
        printf(RED "‚ùå A lista est√° vazia ou n√£o est√° corretamente inicializada.\n" RESET);
    }
}


/*
Maria isso deve ser executado no power shell para rodar Emoji
cd C:\Importante\C (caminho at√© a pasta em que se encontra o .exe)
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8 
.\programa.exe (nome do programa.exe)
*/

// Fun√ß√£o para exibir mensagens de boas-vindas sobre uma lista de Emojis
void boasVindas() {
    // Exibe uma borda superior da caixa de boas-vindas
    printf("\n" GREEN BOLD "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" RESET "\n");
    // Mensagem de boas-vindas com destaque para a "Lista de Emojis"
    printf(GREEN BOLD "‚ïë" RESET " üåüüéâ " BOLD GREEN "Bem-vindo √† " RESET GREEN BOLD "Lista de Emojis do Zap" RESET GREEN BOLD " üéâüåü " GREEN BOLD "                              ‚ïë" RESET "\n");
    // Mensagem sobre explorar Emojis
    printf(GREEN BOLD "‚ïë" RESET " üòÄüòç " YELLOW "Explore uma sele√ß√£o divertida de Emojis para usar!" RESET GREEN BOLD " üòçüòÄ " GREEN BOLD "              ‚ïë" RESET "\n");
    // Mensagem sobre escolher √≠cones e express√µes
    printf(GREEN BOLD "‚ïë" RESET " üé®üñºÔ∏è " MAGENTA "Escolha entre uma variedade de √≠cones e express√µes!" RESET GREEN BOLD " üñºÔ∏èüé® " GREEN BOLD "             ‚ïë" RESET "\n");
    // Mensagem sobre personaliza√ß√£o com Emojis
    printf(GREEN BOLD "‚ïë" RESET " üõ†Ô∏è‚ú® " GREEN "Personalize suas mensagens com Emojis √∫nicos!" RESET GREEN BOLD " ‚ú®üõ†Ô∏è " GREEN BOLD "                   ‚ïë" RESET "\n");
    // Exibe uma borda inferior da caixa de boas-vindas
    printf(GREEN BOLD "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" RESET "\n\n");
}

void exibeMenu() {
    // Exibe um menu colorido e com emojis personalizados para cada op√ß√£o
    printf(GREEN "\nüåü‚ú® Bem-vindo ao Gerenciador de Emojis ‚ú®üåü\n\n" RESET);
    printf(YELLOW "Escolha uma op√ß√£o:\n" RESET);
    printf(RED "üòÑ [1] - Inserir Emoji\n" RESET);
    printf(GREEN "üëÄ [2] - Exibir Emojis\n" RESET);
    printf(MAGENTA "üîÑ [3] - Ordenar Emojis (Stooge Sort)\n" RESET);
    printf(BLUE "üîç [4] - Consultar Emoji\n" RESET);
    printf(CYAN "üóëÔ∏è [5] - Remover Emoji por Popularidade\n" RESET);
    printf(YELLOW "üåê [6] - Unir Listas\n" RESET);  
    printf(RED "üö™ [7] - Sair\n" RESET);  
    printf(YELLOW "\nüëâ Digite sua escolha: " RESET);
}


// Fun√ß√£o para unir duas listas e permitir inser√ß√£o na segunda
void unirListas(ListaDuplamenteEncadeada* lista1, ListaDuplamenteEncadeada* lista2) {
    char emoji[16];
    int popularidade;
    int opcao = 1;
    printf(CYAN "üì• Insira elementos na segunda lista.\n\n" RESET);
    limpar();

    // Loop para inserir elementos na segunda lista
    while (opcao != 0) {
        Insere(lista2);  // Insere o emoji na segunda lista
        printf(GREEN "\n\n‚ûï Deseja inserir outro emoji? " RESET);
        printf(YELLOW "üòÉ (1 - Sim) " RESET);
        printf(RED "‚ùå (0 - N√£o): " RESET);
        scanf("%d", &opcao);
        limparbuffer();
        limpar();
    }
    printf(LIGHT_CYAN "üîÑ Ordenar Lista1...\n\n" RESET);
    ordenarLista(lista1);
    limpar();
    printf(LIGHT_CYAN "üîÑ Ordenar Lista2...\n\n" RESET);
    ordenarLista(lista2);
    limpar();
    printf(YELLOW "üåê Unindo as duas listas...\n" RESET);
    limpar();
    

    if (lista1 == NULL || lista2 == NULL) {
        printf(RED "‚ùå Uma ou ambas as listas s√£o nulas.\n" RESET);
        return;
    }

    if (lista1->cabeca == NULL) {  // Se a primeira lista est√° vazia
        lista1->cabeca = lista2->cabeca;
        lista1->cauda = lista2->cauda;
    } else if (lista2->cabeca == NULL) {  // Se a segunda lista est√° vazia
        return;
    } else {
        // Conecta a cauda da primeira lista √† cabe√ßa da segunda lista
        lista1->cauda->prox = lista2->cabeca;
        lista2->cabeca->ant = lista1->cauda;

        // Atualiza a cauda da primeira lista para ser a cauda da segunda
        lista1->cauda = lista2->cauda;
    }

    // A segunda lista agora est√° vazia, para evitar refer√™ncias duplicadas
    lista2->cabeca = NULL;
    lista2->cauda = NULL;

    printf(GREEN "‚úÖ Listas unidas com sucesso!\n" RESET);
    limpar();
    Exibe(lista1);
}
