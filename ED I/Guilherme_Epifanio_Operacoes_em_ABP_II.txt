#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Estrutura para nÃ³ da Ã¡rvore binÃ¡ria ğŸŒ³
struct NoArvore {
    struct NoArvore* esq;  // Ponteiro para o filho esquerdo â†–ï¸
    struct NoArvore* dir;  // Ponteiro para o filho direito â†—ï¸
    int dado;              // Valor armazenado no nÃ³ ğŸ“¦
};

typedef struct NoArvore* ArvoreBinaria;  // DefiniÃ§Ã£o do tipo da Ã¡rvore binÃ¡ria ğŸŒ²

ArvoreBinaria inicializarArvore() {
    return NULL;  // Retorna uma Ã¡rvore vazia ğŸª¶
}

// FunÃ§Ã£o para buscar valor na Ã¡rvore ğŸ”
ArvoreBinaria buscarValor(ArvoreBinaria raiz, int alvo) {
    ArvoreBinaria atual = raiz;
    while (atual) {
        if (atual->dado == alvo) return atual;  // Valor encontrado âœ…
        atual = (alvo < atual->dado) ? atual->esq : atual->dir;  // Desce para o filho esquerdo ou direito ğŸ”½
    }
    return NULL;  // Valor nÃ£o encontrado âŒ
}

// FunÃ§Ã£o para encontrar o antecessor (mÃ¡ximo da subÃ¡rvore esquerda) ğŸ§­
ArvoreBinaria encontrarAntecessor(ArvoreBinaria no) {
    ArvoreBinaria atual = no->esq;
    while (atual && atual->dir) {  // Percorre para encontrar o maior valor da subÃ¡rvore esquerda ğŸ¹
        atual = atual->dir;
    }
    return atual;
}

// FunÃ§Ã£o para inserir valor na Ã¡rvore ğŸŒ±
ArvoreBinaria inserirValor(ArvoreBinaria raiz, int valor) {
    if (!raiz) {  // Se a Ã¡rvore estiver vazia, cria um novo nÃ³ ğŸ†•
        ArvoreBinaria novoNo = malloc(sizeof(struct NoArvore));
        if (!novoNo) return raiz;  // Se falhar na alocaÃ§Ã£o, retorna NULL ğŸ’¥
        
        novoNo->dado = valor;   // Atribui o valor ao nÃ³ ğŸ“‘
        novoNo->esq = novoNo->dir = NULL;  // Inicializa os ponteiros dos filhos como NULL ğŸ›‘
        return novoNo;
    }

    // Se o valor for menor, insere na subÃ¡rvore esquerda â†–ï¸
    // Se o valor for maior, insere na subÃ¡rvore direita â†—ï¸
    if (valor < raiz->dado) {
        raiz->esq = inserirValor(raiz->esq, valor);
    } else {
        raiz->dir = inserirValor(raiz->dir, valor);
    }
    
    return raiz;
}

// FunÃ§Ã£o para remover valor da Ã¡rvore ğŸ—‘ï¸
ArvoreBinaria removerValor(ArvoreBinaria raiz, int valor) {
    if (!raiz) return NULL;  // Se nÃ£o encontrar o valor, retorna NULL ğŸš«
    
    // Se o valor for menor, busca na subÃ¡rvore esquerda â†–ï¸
    // Se o valor for maior, busca na subÃ¡rvore direita â†—ï¸
    if (valor < raiz->dado) {
        raiz->esq = removerValor(raiz->esq, valor);
        return raiz;
    }
    
    if (valor > raiz->dado) {
        raiz->dir = removerValor(raiz->dir, valor);
        return raiz;
    }
    
    // Se o nÃ³ a ser removido tiver um ou nenhum filho
    if (!raiz->esq) {
        ArvoreBinaria temp = raiz->dir;
        free(raiz);  // Libera a memÃ³ria do nÃ³ removido ğŸ’¾âŒ
        return temp;
    }
    
    if (!raiz->dir) {
        ArvoreBinaria temp = raiz->esq;
        free(raiz);  // Libera a memÃ³ria do nÃ³ removido ğŸ’¾âŒ
        return temp;
    }
    
    // Se o nÃ³ a ser removido tiver dois filhos, encontra o antecessor e substitui o nÃ³ ğŸ› ï¸
    ArvoreBinaria antecessor = encontrarAntecessor(raiz);
    raiz->dado = antecessor->dado;
    raiz->esq = removerValor(raiz->esq, antecessor->dado);
    
    return raiz;
}

// FunÃ§Ã£o para realizar o percurso em ordem (esquerda, raiz, direita) ğŸ”„
void percursoEmOrdem(ArvoreBinaria raiz, int* primeiro) {
    if (!raiz) return;  // Se o nÃ³ for NULL, nÃ£o faz nada ğŸš«
    percursoEmOrdem(raiz->esq, primeiro);  // Percorre a subÃ¡rvore esquerda â†–ï¸
    printf("%s%d", *primeiro ? "" : " ", raiz->dado);  // Exibe o valor da raiz ğŸ‘€
    *primeiro = 0;  // Marca que jÃ¡ passou pela primeira raiz ğŸŒŸ
    percursoEmOrdem(raiz->dir, primeiro);  // Percorre a subÃ¡rvore direita â†—ï¸
}

// FunÃ§Ã£o para realizar o percurso prÃ©-ordem (raiz, esquerda, direita) ğŸ”„
void percursoPreOrdem(ArvoreBinaria raiz, int* primeiro) {
    if (!raiz) return;  // Se o nÃ³ for NULL, nÃ£o faz nada ğŸš«
    printf("%s%d", *primeiro ? "" : " ", raiz->dado);  // Exibe o valor da raiz ğŸ‘€
    *primeiro = 0;  // Marca que jÃ¡ passou pela primeira raiz ğŸŒŸ
    percursoPreOrdem(raiz->esq, primeiro);  // Percorre a subÃ¡rvore esquerda â†–ï¸
    percursoPreOrdem(raiz->dir, primeiro);  // Percorre a subÃ¡rvore direita â†—ï¸
}

// FunÃ§Ã£o para realizar o percurso pÃ³s-ordem (esquerda, direita, raiz) ğŸ”„
void percursoPosOrdem(ArvoreBinaria raiz, int* primeiro) {
    if (!raiz) return;  // Se o nÃ³ for NULL, nÃ£o faz nada ğŸš«
    percursoPosOrdem(raiz->esq, primeiro);  // Percorre a subÃ¡rvore esquerda â†–ï¸
    percursoPosOrdem(raiz->dir, primeiro);  // Percorre a subÃ¡rvore direita â†—ï¸
    printf("%s%d", *primeiro ? "" : " ", raiz->dado);  // Exibe o valor da raiz ğŸ‘€
    *primeiro = 0;  // Marca que jÃ¡ passou pela primeira raiz ğŸŒŸ
}

// FunÃ§Ã£o para processar comandos do usuÃ¡rio âš™ï¸
void processarComando(const char* cmd, ArvoreBinaria* raiz) {
    int val;
    int primeiro;
    
    if (strcmp(cmd, "I") == 0) {  // Inserir valor ğŸ”¼
        scanf("%d", &val);
        *raiz = inserirValor(*raiz, val);
    } 
    else if (strcmp(cmd, "R") == 0) {  // Remover valor âŒ
        scanf("%d", &val);
        *raiz = removerValor(*raiz, val);
    }
    else if (strcmp(cmd, "P") == 0) {  // Procurar valor ğŸ”
        scanf("%d", &val);
        printf("%d %s\n", val, buscarValor(*raiz, val) ? "existe" : "nao existe");
    }
    else if (strcmp(cmd, "INFIXA") == 0) {  // Percurso em ordem ğŸŒ²
        primeiro = 1;
        percursoEmOrdem(*raiz, &primeiro);
        printf("\n");
    }
    else if (strcmp(cmd, "PREFIXA") == 0) {  // Percurso prÃ©-ordem ğŸŒ³
        primeiro = 1;
        percursoPreOrdem(*raiz, &primeiro);
        printf("\n");
    }
    else if (strcmp(cmd, "POSFIXA") == 0) {  // Percurso pÃ³s-ordem ğŸ‚
        primeiro = 1;
        percursoPosOrdem(*raiz, &primeiro);
        printf("\n");
    }
}

int main() {
    char comando[10];  // VariÃ¡vel para armazenar o comando ğŸ“
    ArvoreBinaria arvore = inicializarArvore();  // Inicializa a Ã¡rvore vazia ğŸŒ±
    
    while (scanf("%s", comando) != EOF) {  // LÃª os comandos atÃ© o fim do arquivo â¹ï¸
        processarComando(comando, &arvore);  // Processa o comando ğŸ› ï¸
    }
    
    return 0;  // Finaliza o programa âœ…
}
